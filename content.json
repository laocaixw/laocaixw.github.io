{"meta":{"title":"laocaixw","subtitle":null,"description":null,"author":"laocaixw","url":"http://laocaixw.github.io"},"pages":[{"title":"关于我","date":"2017-11-18T03:20:00.000Z","updated":"2017-12-31T05:21:04.508Z","comments":true,"path":"about.html","permalink":"http://laocaixw.github.io/about.html","excerpt":"","text":"ID：laocaixw 我的简历 我的作品：1. Android安福相册：下载地址 2. 小程序小小港代街： 3. 网站悠悠GO购"},{"title":"404","date":"2017-11-16T07:30:00.000Z","updated":"2017-11-16T08:16:25.653Z","comments":true,"path":"404.html","permalink":"http://laocaixw.github.io/404.html","excerpt":"","text":""}],"posts":[{"title":"设计模式学习系列（9）--组合模式","slug":"Design_Mode_9_Composite","date":"2018-06-21T10:00:00.000Z","updated":"2018-06-22T04:27:57.200Z","comments":true,"path":"2018/06/21/Design_Mode_9_Composite/","link":"","permalink":"http://laocaixw.github.io/2018/06/21/Design_Mode_9_Composite/","excerpt":"","text":"组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 抽象构件，不管是树枝还是叶子都是继承此构件： 123456789public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; public abstract void display(int level);&#125; 树枝构件，持有子构件集合，即树枝上可以长出树枝或叶子： 123456789101112131415161718192021222324252627282930313233public class Composite extends Component &#123; int level = 0; public Composite(String name) &#123; super(name); &#125; private ArrayList&lt;Component&gt; componentList = new ArrayList&lt;&gt;(); public void add(Component component) &#123; this.componentList.add(component); &#125; public void remove(Component component) &#123; this.componentList.remove(component); &#125; public ArrayList&lt;Component&gt; getChild() &#123; return this.componentList; &#125; @Override public void display(int level) &#123; this.level = level + 1; System.out.println(name); for (Component component : componentList) &#123; for (int i = 0; i &lt;= level; i++) &#123; System.out.print(\"-\"); &#125; component.display(this.level); &#125; &#125;&#125; 叶子构件，叶子上不可以长出树枝或叶子： 12345678910public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override public void display(int level) &#123; System.out.println(name); &#125;&#125; 客户端代码：123456789101112131415161718192021public class Demo &#123; public static void main(String[] args) &#123; // 根节点（树枝root） Composite root = new Composite(\"root\"); // 根节点可以长出叶子A、B root.add(new Leaf(\"A\")); root.add(new Leaf(\"B\")); // 根节点也可以长出树枝X Composite x = new Composite(\"X\"); // 树枝X可以长出叶子XA、XB x.add(new Leaf(\"XA\")); x.add(new Leaf(\"XB\")); // 树枝X也可以长出树枝XX Composite xx = new Composite(\"XX\"); // 树枝XX还可以接着长出叶子XXA xx.add(new Leaf(\"XXA\")); x.add(xx); root.add(x); root.display(0); &#125;&#125; 输出结果： 12345678root-A-B-X--XA--XB--XX---XXA 组合模式的优点： 高层模块调用简单。由于所有节点都是 Component，局部或整体对调用者来说没有区别； 节点自由增加。如果想增加树枝或叶子，只需在其父节点处添加即可。 组合模式的缺点： 不易控制构件类型； 不易使用继承的方法来增加新的行为。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"设计模式学习系列（8）--适配器模式","slug":"Design_Mode_8_Adapter","date":"2018-06-16T02:30:00.000Z","updated":"2018-06-22T03:03:07.653Z","comments":true,"path":"2018/06/16/Design_Mode_8_Adapter/","link":"","permalink":"http://laocaixw.github.io/2018/06/16/Design_Mode_8_Adapter/","excerpt":"","text":"适配器模式：将一个类的接口变换成客户端所需要的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作 客户端所需要的接口： 123public interface Target &#123; public void request();&#125; 原有的、需要被适配的类： 123456public class Adaptee &#123; public void doSomething() &#123; // 原有的业务逻辑 System.out.println(\"doSomething\"); &#125;&#125; 适配器： 123456public class Adapter extends Adaptee implements Target &#123; @Override public void request() &#123; super.doSomething(); &#125;&#125; 或对象适配器： 123456789101112public class Adapter2 implements Target &#123; private Adaptee adaptee; public Adapter2(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void request() &#123; adaptee.doSomething(); &#125;&#125; 客户端代码： 1234567public class Demo &#123; public static void main(String[] args) &#123; Target target = new Adapter(); // Target target = new Adapter2(new Adaptee()); target.request(); &#125;&#125; 这里客户端所要用的是 Adaptee 的业务逻辑，但是需要的接口是 Target 类型的接口，原有的类 Adaptee 里提供的接口无法满足客户端的需求。所以这里就可以使用适配器 Adapter 来实现，根据 Target 的接口，来使用 Adaptee 的业务逻辑。 输出结果： 1doSomething 适配器模式的使用场景在已投产的系统中，当需要使用已有的类，但是这个类又不符合系统的接口时，使用适配器模式是最适合的，它可以将不符合系统的接口的类转换成符合系统的接口来使用。 《大话设计模式》中提到的一个典故：魏文王问扁鹊家中三兄弟谁的医术最好，扁鹊告诉魏文王，大哥最牛逼，然后是二哥，然后才是扁鹊。大哥治病都是在没发病之前就治好了，二哥是在刚发病的时候治好，而扁鹊病情严重的时候才治好的。这个故事告诉我们，适配器模式虽然好，但是最好还是在问题发生之前预防它，考虑全面，做好适配。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Android与Vue的交互","slug":"Android_WebView_Vue","date":"2018-05-17T10:00:00.000Z","updated":"2018-05-25T05:59:17.861Z","comments":true,"path":"2018/05/17/Android_WebView_Vue/","link":"","permalink":"http://laocaixw.github.io/2018/05/17/Android_WebView_Vue/","excerpt":"","text":"做过 Android 混合开发的，应该都知道 Android 中 Java 代码和 Javascript 代码之间的交互怎么做。 首先回顾一下 Java 和 Javascript 之间的交互。 JavaScript 调用 JavaAndroid 中 WebView 添加供 Html 页面调用的 Java 方法： 12345678mWebView.addJavascriptInterface(new DirectToJS(), \"AndroidObj\");class DirectToJS &#123; @JavascriptInterface public void showToast() &#123; Toast.makeText(this, \"Android Toast\",Toast.LENGTH_SHORT).show(); &#125;&#125; Html 页面中 JavaScript 调用 Java 方法的方式如下： 1window.AndroidObj.showToast(); JavaScript 代码中: window 是网页的 Window 实体，这个做前端开发的人都非常熟悉；AndroidObj 是 Android 端给 WebView 提供的一个实体，Android 会将这个实体赋给 WebView 的 window；showToast() 就是 Java 提供给 Html 的方法。 Java 调用 JavaScript首先 Html 上写个普通的 JavaScript 方法： 123function showAlert()&#123; alert(\"Html Alert\");&#125; Android 中只要执行以下代码即可： 1mWebView.loadUrl(\"javascript:showAlert()\"); Vue 框架上的坑如果前端用的是 Vue 框架，那么如果你在 js 脚本上直接写一个方法，Android 是调用不到的，无论是写在那个位置。 这是因为 Vue 框架中，脚本上的方法不是属于 window 的方法，你应该将要提供给 Android 调用的方法赋给 window，这样，Android 中才能调得到： 123window['showAlert'] = &#123; alert(\"Html Alert\");&#125; 总得来说，对于普通的网页，写在 js 脚本上的方法，默认都是属于 window 实体的；而 Vue 框架中，由于框架内部的实现机制比较特殊，你写在 js 脚本上的方法，不是真正页面上的方法，所以在 Android 中是调用不到的。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Java中的四种引用","slug":"Java_Reference","date":"2018-05-09T02:00:00.000Z","updated":"2018-05-10T06:38:38.342Z","comments":true,"path":"2018/05/09/Java_Reference/","link":"","permalink":"http://laocaixw.github.io/2018/05/09/Java_Reference/","excerpt":"Java 中有四种引用：强引用、软引用、弱引用、虚引用。引用的存在，就是为了让开发者可以更好地管理内存。","text":"Java 中有四种引用：强引用、软引用、弱引用、虚引用。引用的存在，就是为了让开发者可以更好地管理内存。 1. 强引用强引用是指创建一个对象并把这个对象赋给一个引用变量。 当一个对象有具体指向强引用时，JVM 宁可抛出 OutOfMemory 也不会去回收它。强引用是我们平时最常用到的引用，如： 1Person person = new Person(); 1String str = \"Hello World !\"; 当然，Java 对象有自己的作用域，在作用域之外，对象已经相当于不存在了，对应的也会被回收。 如果希望回收强引用指向的对象，可以直接给引用赋值为空，即 person = null; ，那么 JVM 会在适当的时机回收该对象。例如，Vector 类的 clear 方法中就是通过将引用赋值为 null 来实现清理工作的。 2. 软引用（SoftReference）如果一个对象具有软引用：当内存足够时，不会被回收；当内存不足时，会被回收。 改变 eclipse JVM 内存（ Window -&gt; Preferences -&gt; Java -&gt; Installs JREs -&gt; Edit -&gt; Default VM arguments 内容改为 -Xmx65m -Xms64m -Xmn32m -Xss16m ，其中 -Xmx65m 为最大内存 ），做如下测试： 123456789int COUNT = 8777180; // 根据 JVM 内存调整SoftReference&lt;Person&gt; personSR = new SoftReference&lt;Person&gt;(new Person());System.gc();System.out.println(\"1:\" + personSR.get());Person[] persons = new Person[COUNT];System.gc();System.out.println(\"2:\" + personSR.get()); 输出如下： 121:com.laocaixw.test.reference.Person@15db97422:null 可以看到 persons 达到一定大小时，软引用 personSR 持有的 person 会被回收，所以 personSR.get() 获取到的值为 null 。 软引用可以用来实现内存敏感的高速缓存，比如网页缓存、图片缓存等。 使用软引用能防止内存泄露，增强程序的健壮性。 另外，需要注意的是：SoftReference 是用来管理引用对象的，但是 SoftReference 本身也是一个对象。当 SoftReference 所管理的对象被回收后，SoftReference 本身并没有被回收，但是它已经没有任何作用了。如果内存中存在大量无用的 SoftReference，也会导致内存泄漏。所以，我们应该在合适的时机将无用的 SoftReference 赋值为 null，释放掉它所占用的内存。 SoftReference 可以和 ReferenceQueue 一起使用。创建 SoftReference 的时候将 ReferenceQueue 传入 SoftReference 的构造方法。当 SoftReference 所管理的对象被回收的时候，SoftReference 就会被放到 ReferenceQueue 中。 12345678910111213int COUNT = 8777180; // 根据 JVM 内存调整 ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;Person&gt;();SoftReference&lt;Person&gt; personSR = new SoftReference&lt;Person&gt;(new Person(),queue);System.gc();System.out.println(\"1:\" + personSR.get());System.out.println(\"1:\" + personSR);System.out.println(\"1:\" + queue.poll());Person[] persons = new Person[COUNT];System.gc();System.out.println(\"2:\" + personSR.get());System.out.println(\"2:\" + queue.poll()); 输出如下： 123451:com.laocaixw.test.reference.Person@15db97421:java.lang.ref.SoftReference@6d06d69c1:null2:null2:java.lang.ref.SoftReference@6d06d69c 3. 弱引用（WeakReference）弱引用相对软引用，生命周期更短暂。当 JVM 进行垃圾回收时，无论内存是否充足，弱引用管理的对象都会被回收。 1234WeakReference&lt;Person&gt; personWR = new WeakReference&lt;Person&gt;(new Person());System.out.println(\"1:\" + personWR.get());System.gc();System.out.println(\"2:\" + personWR.get()); 输出如下： 121:com.laocaixw.test.reference.Person@15db97422:null 当然，WeakReference 和 SoftReference 一样，也可以和 ReferenceQueue 一起使用。 4. 虚引用（PhantomReference）虚引用也称幽灵引用，它和前面的软引用、弱引用不同，并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 1234567891011121314ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;Person&gt;();Person person = new Person();PhantomReference&lt;Person&gt; personPR = new PhantomReference&lt;Person&gt;(person, queue);System.out.println(\"1:\" + personPR.get());System.out.println(\"1:\" + queue.poll());System.gc();System.out.println(\"2:\" + personPR.get());System.out.println(\"2:\" + queue.poll());person = null;System.gc();System.out.println(\"3:\" + personPR.get());System.out.println(\"3:\" + queue.poll()); 输出如下： 1234561:null1:null2:null2:null3:null3:java.lang.ref.PhantomReference@15db9742 PhantomReference 必须和 ReferenceQueue 一起使用。当与 PhantomReference 关联的对象被 JVM 回收时，这个 PhantomReference 就会被放到 ReferenceQueue 中。程序可以通过判断 ReferenceQueue 中是否加入了该 PhantomReference 来判断该对象是否被回收了。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://laocaixw.github.io/tags/Java/"}]},{"title":"用Jenkins自动部署hexo搭建的GitHub静态博客","slug":"Blog_Hexo_GitHub_Jenkins","date":"2018-04-02T05:30:00.000Z","updated":"2018-04-06T06:39:59.083Z","comments":true,"path":"2018/04/02/Blog_Hexo_GitHub_Jenkins/","link":"","permalink":"http://laocaixw.github.io/2018/04/02/Blog_Hexo_GitHub_Jenkins/","excerpt":"hexo 为我们提供了一套非常方便的静态博客搭建框架，我们只需要编写文章的 MarkDown 文件即可。但是即便方便，还是会有几个繁琐的步骤：每次写一篇博客都需要执行编译命令，再将新生成的网页代码提交到 GitHub；而且，如果博客是由团队成员共同贡献，很难做到协同维护。使用 Jenkins 可以帮我们一定程度上解决这两个问题。","text":"hexo 为我们提供了一套非常方便的静态博客搭建框架，我们只需要编写文章的 MarkDown 文件即可。但是即便方便，还是会有几个繁琐的步骤：每次写一篇博客都需要执行编译命令，再将新生成的网页代码提交到 GitHub；而且，如果博客是由团队成员共同贡献，很难做到协同维护。使用 Jenkins 可以帮我们一定程度上解决这两个问题。 一、基本思路Jenkins 是一套非常常用且好用的自动化构建工具，也为我们提供了很多插件。这其中会用到 GitHub 提供的 WebHook 功能，GitHub 收到一个 Push 后，会向 Jenkins 服务器发起一条 Post 请求，告诉 Jenkins 现在可以去执行部署操作了。 二、安装 JenkinsJenkins 的安装过程可以完全参考官网：Jenkins 官网，不同系统有不同的安装方法，比如 CentOS： 只要按照步骤安装即可，基本上都会包含以下步骤： 安装 Jenkins，一般安装稳定版会比较稳妥； 安装 Java 环境，Jenkins 是需要 Java 环境的； 启动 Jenkins 服务，设置开机自启动； 关闭相应的防火墙； 安装完成后，访问 http://你的服务器ip:8080/ 即可，Jenkins 默认端口是8080，有些云服务器会限制端口的访问，这时候需要在控制台修改配置，比如阿里云是这样的： 安装好 Jenkins 后，第一次访问会让你输入密码，页面上会提示具体是哪个文件，用 vim 打开即可查看，比如 CentOS 默认是：/var/lib/jenkins/secrets/initialAdminPassword。 进入后，可以创建新的用户，以后就可以使用这个用户访问 Jenkins 了。 新建账号后，会提示安装插件，一般直接按推荐安装，如果有报错，最好点击重试，多试几次一般都会安装成功，如果实在装不上那就先跳过吧 三、在服务器上安装 hexo在服务器上安装 hexo，是为了可以让 Jenkins 自动部署。安装方法参考之前的文章：基于hexo搭建GitHub静态博客。Linux 肯定会不一样，请自行百度/谷歌解决。为了拉/上传代码，还需要安装 Git。 安装好 hexo 后，后面构建生成静态网站、上传网页新代码等，都要在这里做了。所以你需要做的有： 初始化一套和你原来博客一样的配置，包括配置和主题； 从你的 Git 上拉一份你博客网页（xxx.github.io）项目的代码，用于提交新代码； 新建一个只存放 hexo 的 source 文件夹的库，就是 hexo 中放 md、img 等源文件的文件夹，这里暂时称它为 blog_source； 四、配置 Jenkins 自动构建项目自动构建是基于上一节中新建的 blog_source 项目进行的。 新建任务，输入任务名，选择自由风格即可： 配置项目，设置 GitHub 项目地址： 源码管理，这里一定要注意，设置为你的 blog_source 的 GitHub 源码 Url，否则 Jenkins 收到 GitHub 的 Post 请求的时候，是不知道你到底要执行那个任务的： 构建触发器，选 GitHub hook： 构建，这里就是真正的构建步骤，可以按你的需求填。我这边全部用 shell 命令执行： 配置好后，点击应用即可。 注意：如果构建的过程中提示没有权限之类的错误，请设置一下 Jenkins 用户。Jenkins 安装好后，会自动新建一个用户叫 jenkins，可以把它改为 root 用户。 CentOS 配置文件为 /etc/sysconfig/jenkins ，修改 JENKINS_USER 项为 root 即可： 1JENKINS_USER=&quot;root&quot; 另外，还需要配置 Jenkins 的 GitHub 插件的 hook url： 五、 配置 Github 项目配置 blog_source 项目的 Webhooks ，一定要以 / 结尾： 六、配置结束完成以上配置后，就可以试试向 blog_source push 代码了，如果 Jenkins 在构建了，就说明配置成功了，等构建完成，就可以预览你的博客了。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://laocaixw.github.io/tags/hexo/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://laocaixw.github.io/tags/Jenkins/"}]},{"title":"设计模式学习系列（7）--装饰模式","slug":"Design_Mode_7_Decorator","date":"2018-01-07T02:30:00.000Z","updated":"2018-06-10T03:52:27.826Z","comments":true,"path":"2018/01/07/Design_Mode_7_Decorator/","link":"","permalink":"http://laocaixw.github.io/2018/01/07/Design_Mode_7_Decorator/","excerpt":"","text":"装饰模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。 下面用汽车装饰写个例子。 汽车接口（Component） 123public interface Car &#123; public void show();&#125; 具体汽车类-奔驰（ConcreteComponent） 123456public class Benz implements Car &#123; @Override public void show() &#123; System.out.println(\"奔驰\"); &#125;&#125; 汽车装饰抽象类（Decorator） 1234567891011121314public abstract class CarDecorator implements Car &#123; private Car car = null; public CarDecorator(Car car) &#123; this.car = car; &#125; @Override public void show() &#123; if (car != null) &#123; car.show(); &#125; &#125;&#125; 具体装饰类-黑色喷漆（ConcreteDecorator） 1234567891011public class DecoratorBlack extends CarDecorator &#123; public DecoratorBlack(Car car) &#123; super(car); &#125; @Override public void show() &#123; super.show(); System.out.println(\"黑色喷漆\"); &#125;&#125; 具体装饰类-GPS（ConcreteDecorator） 1234567891011public class DecoratorGPS extends CarDecorator &#123; public DecoratorGPS(Car car) &#123; super(car); &#125; @Override public void show() &#123; super.show(); System.out.println(\"安装GPS\"); &#125;&#125; 客户端代码： 12345678public class Demo &#123; public static void main(String[] args) &#123; Car benz = new Benz(); CarDecorator black = new DecoratorBlack(benz); CarDecorator gps = new DecoratorGPS(black); gps.show(); &#125;&#125; 输出结果： 123奔驰黑色喷漆安装GPS 装饰模式的优点 装饰类和被装饰类可以独立发展，不会互相耦合。被装饰类 Component 无需知道装饰类 Decorator；装饰类是从外部扩展被装饰类的功能，而不知道被装饰类的具体内容。 装饰模式可以动态地扩展一个实现类的功能。当系统需要新的功能时，只需要增加装饰类，而不用修改原系统功能。 装饰模式是继承的一种替代方案。装饰类不管装饰多少层，原来的对象还是原来的对象；而在继承中，如果修改了父类，会影响到所有子类。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"2017年总结","slug":"Summary_2017","date":"2017-12-30T02:30:00.000Z","updated":"2018-01-09T12:09:35.813Z","comments":true,"path":"2017/12/30/Summary_2017/","link":"","permalink":"http://laocaixw.github.io/2017/12/30/Summary_2017/","excerpt":"","text":"突然发现时间过得好快，2017 年马上就过去了。这也是自己转行做 IT 后第一次写总结，以前都是老师或者领导布置任务，属于被写总结。从去年六月份从国企辞职，到现在也有一年半的时间了，就对自己这一点半做一个总结吧。 参加工作一年左右开始有了转行做 IT 的想法，本科学的是自动化专业，那时候只有在学校学的一些 C 语言基础，可能还学过一些其他的软件基础吧，但是对于我这种学渣来说，应该是已经还给老师了，或者说压根就没从老师那里拿到过吧！另外，就是以前工作中 Excel 用的比较多，经常接触公式和 VBA。刚开始有转行想法的时候，根本不知道从何下手，于是就从最常见的 Java 开始学起了。后来网上找资料，稀里糊涂就在网易云课堂上学了 Mars 老师的《Java4Android》视频教程，然后又在知乎上看到张哥（stormzhang）的 Android 学习之路，从此就入了 Android 之坑。后来学习主要是通过极客学院、慕课网等网站上的视频教程，和郭霖大神的《第一行代码》。从开始学 Java 到正式转行，断断续续地也花了有一年的时间，中间几度想放弃，所幸最后还是坚持了下来。 安福相册 安福相册是自己做的第一个项目，也主要是为了找工作所做的项目。功能比较简单，是供给莆田安福市场卖家使用的一个工具。安福市场这边的档口（批发商）会把自己的商品图片放在又拍图片管家上，而卖家选商品、上架商品，都需要从相应批发商的图片相册上找商品图，一张一张下载到电脑，然后发布上架等。下载图片的步骤还是挺繁琐的，于是自己萌生了一个想法，做一个产品，方便浏览图片，一键下载图片等。产品实现也挺简单的，就是爬取又拍管家的图片，显示到应用上。另外，还做了一键分享朋友圈的功能，还用了 Bmob 后端云的免费应用数据服务搭建了用户系统等等。靠这个项目找到了工作，后来业余时间也有断断续续的维护。 推广、搁置今年三四月份的时候，突然萌生了想把安福相册推向市场的想法，于是打印了1000张名片，花了一个晚上，发了200多张，发现反响不是很好，甚至都没几个人注册，于是剩下的700多张至今还躺在抽屉里。总结了一下这次的冲动，自己一个人搞，不会推广，很多东西都没考虑到位。比如，二维码下载链接，是直接指向 apk 下载地址的，需要从浏览器打开下载，但是大部分人都认为扫二维码是微信专有的！所以应该准备一个下载页面，如果是从普通浏览器打开，可以直接下载；如果是从微信打开，应该给用户一个从浏览器打开的提示，或者更好的做法是跳转到腾讯应用宝的微下载。比如，卖家大多数是用 iPhone 手机的，无法使用 APP。比如，名片上的文案写得不够好，可能有些用户没说明都看不懂，这也说明了文案的重要性。比如，注册需要邮箱验证这种麻烦的操作。等等原因。后来想着这也不是个事，于是把应用发到了各大应用市场，只有百度应用和腾讯应用宝通过了审核，其他平台审核都以应用功能过于简单不给通过，我这个是大道至简好不好！ 惊喜、重拾前段时间有一次登录 Bmob 后台，发现用户竟然有100个左右，这算是惊喜吧，虽然不知道活跃量如何，但这也说明了应用市场是有点作用的。于是重构了应用，使用 MVP 框架，集成了友盟统计，修复了一些常见的崩溃等。重构它一来是为了让安福相册可以持续，也是对这一年来技术的一个总结吧。应用目前还没完善，等这几天完善一些再发布新版本。 SuspendButtonLayout SuspendButtonLayout 是一个 Android 的控件，一个可以随意拖动的功能按钮。在 GitHub 上开源了，在Android 开源项目集合上发了一次，一周内竟然就收获了四五十个 Star，目前有80多个 Star 也是一个小惊喜吧。有时间会优化一下这个控件，换一种实现方式，目标是用起来更方便。 小小港代街 小小港代街是一个微信小程序项目。数据也是存在 Bmob 后端云，用了 Bmob 的云逻辑（目前已经关闭，改用自己的云服务器）来获取 OpenId 等，用的快递鸟的物流查询接口；另外还顺手做了个 Android 版的后台管理系统，用来上架商品和管理订单和物流。 去年九月份的时候微信发布了小程序，后来今年五六月份左右有个朋友找到我，问我小程序怎么做，如果可以的话，想合作让我做一个商城类的小程序，他负责推广。因为自己大概看过小程序的文档，知道不是很难，另外也可以学习一下，就答应了下来，但是前提是需要点时间，因为是利用业余边学边做的。大概六七月就发布上线了，后来这个朋友由于忙于其他事务（估计是懒）没空去推广，小程序也暂时搁置了。虽然小小港代街搁置了，但自己再中间也经历和学到了一些其他事务，如办理微信认证等，也姑且算是提升了能力吧。 悠悠Go购 悠悠GO购是一个淘宝导购的网站，目前也只是把它做出来，没有做搜索引擎优化和网站推广。应该有人知道淘宝客，就是如果有人通过这个网站的链接购买了淘宝的商品，网站站长可以得到少量佣金。这个网站后台是用 PHP 写的，使用 Thinkphp5 框架，页面用了响应式的布局，适配了电脑端和手机端。网站也配了 ssl 证书，可以通过 https 访问。服务器用的京东云服务器，因为一次活动，自己直接用优惠价格买了一年。 有一次，我无意中看到淘宝客相关的开放接口，于是产生了做一个网站的想法，然后我就拉了几个朋友一起搞了起来。大家都对做网站一无所知，基本都是从零开始的，也都抱着学习的态度来做。最后网站是做出来了，但是我们这班人都尼玛是程序员，没有一个懂产品、懂推广的，于是网站也就那样了。所以，总结来说，要做一个产品，一定是需要各方面人才的（当然不排除有大神什么都懂）。一个产品，不止于需要技术人把它做出来，还需要有人来优化、推广，让它有更多人使用，让它更有价值。 总结总结这一年多，自己的本职是做 Android 开发，工作上的任务基本都可以及时完成，偶尔也会提出一些技术上奇思妙想（黑科技）的解决方案、项目管理上的优化想法（又吹牛逼了~）。本职工作之外，也学了点其他技能（网站搭建、PHP、小程序），因为技术的更新换代非常快，个人认为这是有必要的。另外，学习完了《大话设计模式》，后面也会陆续把设计模式学习系列写完，算是一遍复习吧。 计划继续做好 Android，本职工作是最需要提高的；继续写点博客，希望可以提高写作水平；因为市场上很多 Android 应用是混合开发，所以也应该学点 H5；因为最近人工智能比较火，看过 Python 的一些基础语法，可以考虑学点人工智能、机器学习方面的东西，甚至有机会的话可以往这个方向转。以上。","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://laocaixw.github.io/tags/总结/"}]},{"title":"设计模式学习系列（6）--代理模式","slug":"Design_Mode_6_Proxy","date":"2017-12-23T02:30:00.000Z","updated":"2018-06-10T03:52:21.316Z","comments":true,"path":"2017/12/23/Design_Mode_6_Proxy/","link":"","permalink":"http://laocaixw.github.io/2017/12/23/Design_Mode_6_Proxy/","excerpt":"","text":"代理模式：为其他对象提供一种代理以控制对这个对象的访问。 代理模式是让代理主题和真实主题实现同一个主题接口，真实主题只管封装好实际的业务逻辑后，由代理负责调用和完成其他附加事务。 抽象主题 Subject 1234public interface Subject &#123; // 请求方法 public void request();&#125; 真实主题 RealSubject 1234567public class RealSubject implements Subject &#123; @Override public void request() &#123; // 业务逻辑操作... System.out.println(\"RealSubject-request\"); &#125;&#125; 代理主题 ProxySubject 12345678910111213141516public class ProxySubject implements Subject &#123; private Subject subject; public ProxySubject(Subject subject) &#123; this.subject = subject; &#125; @Override public void request() &#123; // 请求前可以做些其他操作... System.out.println(\"ProxySubject-before-request\"); subject.request(); // 请求后也可以做些其他操作... System.out.println(\"ProxySubject-after-request\"); &#125;&#125; 客户端代码： 1234567public class Demo &#123; public static void main(String[] args) &#123; RealSubject real = new RealSubject(); ProxySubject proxy = new ProxySubject(real); proxy.request(); &#125;&#125; 输出结果： 123ProxySubject-before-requestRealSubject-requestProxySubject-after-request 代理模式的应用远程代理：为一个对象在不同的地址空间提供局部代表。可以是本机也可以是其他机器，这样可以隐藏一个对象存在于不同地址空间的事实。 虚拟代理：有时需要创建一些开销很大的对象，可以先创建代理对象，而将真实对象延迟创建。 安全代理：控制对象的访问，可以给不同用户提供不同级别的权限。 智能引用：当一个对象被引用时，可以提供一些额外的操作，如记录日志等。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"设计模式学习系列（5）--原型模式","slug":"Design_Mode_5_Prototype","date":"2017-11-24T02:30:00.000Z","updated":"2018-06-10T03:52:13.743Z","comments":true,"path":"2017/11/24/Design_Mode_5_Prototype/","link":"","permalink":"http://laocaixw.github.io/2017/11/24/Design_Mode_5_Prototype/","excerpt":"","text":"原型模式：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。 Java 中内置了克隆机制，Object 类具有一个 clone() 方法。想要使一个类支持克隆，只需要实现 Cloneable 接口，并覆盖 Object 类的 clone() 方法，通常只需要调用父类的 clone() 即可。为了让外部可以调用，clone() 方法一般用 public 修饰。 原型类 Prototype 123public interface Prototype extends Cloneable &#123; Prototype clone();&#125; 具体原型类 ConcretePrototype 12345678910111213141516171819202122232425262728293031323334public class ConcretePrototype implements Prototype &#123; private String type; private String name; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(\"Type:\" + type + \",Name:\" + name); &#125; @Override public Prototype clone() &#123; try &#123; return (Prototype) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 客户端代码： 1234567891011public class Demo &#123; public static void main(String[] args) &#123; ConcretePrototype c1 = new ConcretePrototype(); c1.setType(\"Type-A\"); c1.setName(\"Name-1\"); c1.show(); ConcretePrototype c2 = (ConcretePrototype) c1.clone(); c2.setName(\"Name-2\"); c2.show(); &#125;&#125; 输出结果： 12Type:Type-A,Name:Name-1Type:Type-A,Name:Name-2 原型模式就是复制一份原型实例，再在这份复制的实例中修改某些属性，这样不但省去了重复设置属性的麻烦，而且可以避免重复设置属性过程中因粗心导致的错误；原型模式是在内存二进制流的复制，这要比直接 new 一个对象性能更好；但是 clone() 不会执行构造函数，这也是实际应用中应该进行权衡考虑的。 Java 中 Object 提供的 clone() 方法采用的是浅克隆，即只复制内联关联对象的引用，二不复制关联对象的数据。如果需要深克隆，则需要在覆盖 clone() 方法时手动控制克隆的深度。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Proguard混淆配置","slug":"Android_Proguard","date":"2017-09-26T02:00:00.000Z","updated":"2017-11-16T13:50:25.826Z","comments":true,"path":"2017/09/26/Android_Proguard/","link":"","permalink":"http://laocaixw.github.io/2017/09/26/Android_Proguard/","excerpt":"","text":"1. 基本配置12345678910111213141516171819202122232425262728293031323334# 代码混淆压缩比，在0和7之间，默认为5，一般不需要改-optimizationpasses 5# 混淆时不使用大小写混合，混淆后的类名为小写-dontusemixedcaseclassnames# 指定不去忽略非公共的库的类-dontskipnonpubliclibraryclasses# 指定不去忽略非公共的库的类的成员-dontskipnonpubliclibraryclassmembers# 不做预校验，preverify是proguard的4个步骤之一# Android不需要preverify，去掉这一步可加快混淆速度-dontpreverify# 有了verbose这句话，混淆后就会生成映射文件# 包含有类名-&gt;混淆后类名的映射关系# 然后使用printmapping指定映射文件的名称-verbose-printmapping proguardMapping.txt# 指定混淆时采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不改变-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*# 保护代码中的Annotation不被混淆，这在JSON实体映射时非常重要，比如fastJson-keepattributes *Annotation*# 避免混淆泛型，这在JSON实体映射时非常重要，比如fastJson-keepattributes Signature# 抛出异常时保留代码行号，在第6章异常分析中我们提到过-keepattributes SourceFile,LineNumberTable 特别说明 -dontusemixedcaseclassnames。Windows 用户需要这条配置；UNIX 用户可去掉这条可以进一步缩小包的大小。 2. 需要保留的东西123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 保留所有的本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# 保留了继承自Activity、Application这些类的子类# 因为这些子类，都有可能被外部调用# 比如说，第一行就保证了所有Activity的子类不要被混淆-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService# 如果有引用android-support-v4.jar包，可以添加下面这行-keep public class com.youngheart.app.ui.fragment.** &#123;*;&#125;# 保留在Activity中的方法参数是view的方法，# 从而我们在layout里面编写onClick就不会被影响-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# 枚举类不能被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 保留自定义控件（继承自View）不被混淆-keep public class * extends android.view.View &#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;# 保留Parcelable序列化的类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;# 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;# 对于R（资源）下的所有类及其方法，都不能被混淆-keep class **.R$* &#123; *;&#125;# 对于带有回调函数onXXEvent的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event);&#125; 3. 针对App的量身定制1234567891011121314151617181920212223# 保留实体类和成员不被混淆-keep public class com.youndheart.entity.** &#123; public void set*(***); public *** get*(); public *** is*();&#125;# 保留内嵌类不被混淆-keep class com.example.youngheart.MainActivity$* &#123; *; &#125;# 对WebView的处理-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String)&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, java.lang.String)&#125;# 保留JS方法不被混淆-keepclassmembers class com.example.youngheart.MainActivity$JSInterface1 &#123; &lt;methods&gt;;&#125; 特别说明 实体类。对于实体类，要保留他们的 set 和 get 方法，对于 boolean 型的 get 方法，有些人喜欢命名为 isXXX 的方式，所以不要遗漏了。另外，实体类应该放在一个包下进行管理，这样只要写一次混淆就够了。 内嵌类。内嵌类经常会被忘记而被混淆，最后导致奔溃。最好把内嵌类提取出来，如果非要内嵌，那不就不要忘记配置混淆。 处理反射。应在代码中搜索：forName、getField、getDeclaredField、getMethod、getDeclaredField、newUpdater等方法，保留这些类，以免混淆过程被移除。 自定义View。对于在布局 xml 文件中用到的自定义 View，都不能被混淆。一种思路：在 xml 中使用自定义 View 时，加上包名，以便查找。 4. 针对第三方 jar 包的解决方案123456789101112# 针对android-support-v4.jar的解决方案-libraryjars libs/android-support-v4.jar-dontwarn android.support.v4.**-keep class android.support.v4.** &#123; *; &#125;-keep interface android.support.v4.app.** &#123; *; &#125;-keep public class * extends android.support.v4.**-keep public class * extends android.app.Fragment# 对alipay的混淆处理-libraryjars libs/alipaysdk.jar-dontwarn com.alipay.android.app.**-keep public class com.alipay.** &#123; *; &#125; 其他 eclipse，在 project.properties 中加上： 1proguard.config = proguard.cfg 参考http://www.cnblogs.com/Jax/p/4639221.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android中WebView的配置和填坑记录","slug":"Android_WebView_Config_Record","date":"2017-09-25T02:00:00.000Z","updated":"2018-04-04T08:22:32.683Z","comments":true,"path":"2017/09/25/Android_WebView_Config_Record/","link":"","permalink":"http://laocaixw.github.io/2017/09/25/Android_WebView_Config_Record/","excerpt":"","text":"持续更新中 1. 一些基本配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 硬件加速getActivity().getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);// WebView 配置WebSettings webSettings = mWebView.getSettings();// 生命周期mWebView.onPause(); // 通过 onPause 动作通知内核暂停所有的动作，如 DOM 的解析、plugin 的执行、JavaScript 执行等mWebView.onResume(); // 恢复 WebView，能正常执行网页的响应((ViewGroup) mWebView.getParent()).removeView(mWebView);mWebView.destroy(); // 当 Activity 要 destroy 时，应先将 WebView 移除，再 destroy 掉// 前进后退if (mWebView.canGoBack()) &#123; mWebView.goBack();&#125;if (mWebView.canGoForward()) &#123; mWebView.goForward();&#125;// 缓存相关mWebView.clearCache(true); // 清除缓存mWebView.clearHistory(); // 清除历史mWebView.clearFormData(); // 清除表单数据webSettings.setCacheMode(WebSettings.LOAD_NO_CACHE); // 设置缓存模式// 缓存模式LOAD_DEFAULT: 默认，根据 cache-control 决定是否从网络上取数据LOAD_NORMAL: API level 17 中已经废弃, 从 API level 11 开始作用同 LOAD_DEFAULT 模式LOAD_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache，都使用缓存中的数据LOAD_NO_CACHE: 不使用缓存，只从网络获取数据LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据// js 相关webSettings.setJavaScriptEnabled(true); // 支持 js。如果碰到后台无法释放 js 导致耗电，应在 onStop 和 onResume 里分别设成 false 和 true mWebView.addJavascriptInterface(new WebAppInterface(this), \"android\"); // js 接口webSettings.setPluginsEnabled(true); // 支持插件// 设置自适应屏幕，两者合用webSettings.setUseWideViewPort(true); // 将图片调整到适合 WebView 的大小 webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小// 缩放操作webSettings.setSupportZoom(true); // 支持缩放，默认为 truewebSettings.setBuiltInZoomControls(true); // 设置内置的缩放控件，若为 false，则该 WebView 不可缩放webSettings.setDisplayZoomControls(false); // 隐藏原生的缩放控件 2. WebViewClient 类常用方法1mWebView.setWebViewClient(new MyWebViewClient()); shouldOverrideUrlLoading() 在网页上的所有加载都经过这个方法，这个函数我们可以做很多操作。 onPageStarted() 开始载入页面调用的，我们可以设定一个 loading 的页面，告诉用户程序在等待网络响应。 onPageFinished() 在页面加载结束时调用。我们可以关闭 loading 条，切换程序动作。 onLoadResource() 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。 onReceivedError() 加载页面出现错误时调用。 3. WebChromeClient 类常用方法1mWebView.setWebChromeClient(new MyWebChromeClient()); onProgressChanged() 获得网页的加载进度并显示。 onReceivedTitle() 获取 Web 页中的标题。 onJsAlert() 支持 javascript 的警告框。 onJsConfirm() 支持 javascript 的确认框。 onJsPrompt() 支持 javascript 输入框。 4. Https 和 Http 混合模式从 Android 5.0 开始，WebView 默认不支持同时加载 Https 和 Http 资源。 解决方法：在 webview 加载页面之前，设置加载模式为 MIXED_CONTENT_ALWAYS_ALLOW 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 5. 安全问题addJavascriptInterfaceAndroid 4.2 以前，要采用拦截 prompt() 的方式进行漏洞修复；Android 4.2 以后，只需要对被调用的函数以 @JavascriptInterface 进行注解。 searchBoxJavaBridge_、accessibility、accessibilityTraversal12345if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &#123; mWebView.removeJavascriptInterface(\"searchBoxJavaBridge_\"); mWebView.removeJavascriptInterface(\"accessibility\"); mWebView.removeJavascriptInterface(\"accessibilityTraversal\");&#125; 密码明文存储漏洞1webSettings.setSavePassword(false); 6. 替换 WebView 的加载错误页面1234567891011121314151617@Overridepublic void onReceivedError(WebView view, int errorCode, String description, String failingUrl) &#123; super.onReceivedError(view, errorCode, description, failingUrl); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; showCustErrorPage(); &#125;&#125;@Overridepublic void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123; super.onReceivedError(view, request, error); // 防止高版本机器，网页中的任意一个资源获取不到（比如字体）就显示错误。 // 只有这三种情况才显示错误：没有网络连接、连接超时、找不到页面。 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; showCustErrorPage(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435private View mErrorView;protected void showCustErrorPage() &#123; // 移除 WebView ViewGroup webParentView = (ViewGroup) mWebViewInstance.getParent(); while (webParentView.getChildCount() &gt; 0) &#123; webParentView.removeViewAt(0); &#125; // 生成自定义错误页面 if (mErrorView == null) &#123; mErrorView = View.inflate(mContext, R.layout.webview_error, null); mErrorView.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; showWebViewPage(); mWebViewInstance.reload(); &#125; &#125;); &#125; // 替换为错误页面 ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams( ViewPager.LayoutParams.FILL_PARENT, ViewPager.LayoutParams.FILL_PARENT); webParentView.addView(mErrorView, 0, lp);&#125;protected void showWebViewPage() &#123; // 移除自定义错误页面 ViewGroup webParentView = (ViewGroup) mErrorView.getParent(); while (webParentView.getChildCount() &gt; 0) &#123; webParentView.removeViewAt(0); &#125; // 替换为 WebView ViewGroup.LayoutParams lp = new ViewGroup.LayoutParams( ViewPager.LayoutParams.FILL_PARENT, ViewPager.LayoutParams.FILL_PARENT); webParentView.addView(mWebViewInstance, 0, lp);&#125; 7. 存储第三方 Cookies 相关从 Android 5.0 开始，WebView 默认不能存储第三方 Cookies。 解决方法：在 webview 加载页面之前，设置接受第三方 Cookies。 123if(android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; CookieManager.getInstance().setAcceptThirdPartyCookies(mWebView, true);&#125; 8.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"网站服务器搭建相关","slug":"Web_Server_Setup","date":"2017-09-05T13:30:00.000Z","updated":"2018-05-25T07:47:36.555Z","comments":true,"path":"2017/09/05/Web_Server_Setup/","link":"","permalink":"http://laocaixw.github.io/2017/09/05/Web_Server_Setup/","excerpt":"","text":"以下内容基于此系统版本： 1234Distributor ID: UbuntuDescription: Ubuntu 16.04.2 LTSRelease: 16.04Codename: xenial 安装 Apache2 + PHP + MySQL 安装之前先更新系统 1sudo apt update 安装 Apache2 1sudo apt install apache2 安装 PHP 12sudo apt install phpsudo apt-get install libapache2-mod-php 安装 MySQL 123sudo apt install mysql-server php7.0-mysqlsudo apt-get install mysql-clientmysql_secure_installation 安装 phpmyadmin 1234sudo apt-get install phpmyadminsudo apt-get install php-mbstringsudo apt-get install php-gettextsudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 一些配置 配置 phpmyadmin 打开 PHP 错误日志，修改 /etc/php/7.0/apache2/php.ini 以下两项： 1sudo vim /etc/php/7.0/apache2/php.ini 123display_errors = On // 显示错误日志，出现两次，都要改，不然无效extension=php_mbstring.dll // 开启mbstringerror_reporting = E_ALL | ~E_STRICT 隐藏入口文件 index.php 启用 rewrite： 123sudo a2enmod rewrite// 或sudo ln -s /etc/apache2/mods-available/rewrite.load /etc/apache2/mods-enabled/rewrite.load 修改 AllowOverride 为 All，位置 /etc/apache2/apache2.conf ： 123456&lt;Directory /var/www/&gt; Options Indexes FollowSymLinks # AllowOverride None AllowOverride All Require all granted&lt;/Directory&gt; 配置 HTTPS 启用 ssl 模块 1sudo a2enmod ssl 安装openssl 1sudo apt-get install openssl 创建 CA 签名(不使用密码去除-des3选项) 1openssl genrsa (-des3) -out server.key 1024 创建 CSR (Certificate Signing Request) 1openssl req -new -key server.key -out server.csr #信息注解1234567Country Name (2 letter code) [AU]:CN ←输入国家代码State or Province Name (full name) [Some-State]:FUJIAN ← 输入省名Locality Name (eg, city) []:FUZHOU ←输入城市名Organization Name (eg, company) [Internet Widgits Pty Ltd]:LAOCAIXW ← 输入公司名Organizational Unit Name (eg, section) []:LAOCAIXW ← 输入组织单位名Common Name (eg, YOUR name) []:laocaixw.cn ← 输入主机名(想要开启https的主机名)Email Address []:laocaixw@163.com ←输入电子邮箱地址 自己签发证书 1openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 复制到相应目录 12sudo cp server.crt /etc/ssl/certssudo cp server.key /etc/ssl/private 修改配置文件 12sudo cp /etc/apache2/sites-enabled/000-default.conf /etc/apache2/sites-enabled/001-ssl.confsudo vim /etc/apache2/sites-enabled/001-ssl.conf 在 &lt;VirtualHost *:80&gt; 段中，DocumentRoot 一行的下方加入内容： 12345SSLEngine OnSSLOptions +StrictRequireSSLCertificateFile /etc/ssl/certs/server.crtSSLCertificateKeyFile /etc/ssl/private/server.keySSLCACertificateFile /etc/ssl/apache/root_bundle.crt 加入这段配置时，需保证对应的文件是存在的，否则无法重启服务。 端口修改为：443，即 &lt;VirtualHost *:443&gt; ( ssl 的端口) 自己签发的证书，浏览器会显示为不安全，通过腾讯云获取免费 ssl 证书，放到相应的文件夹中，并修改以上 SSLCertificateFile 和SSLCertificateKeyFile 两项配置，即可。 安装 cURL1sudo apt-get install curl libcurl3 libcurl3-dev php7.0-curl 如果仍然有问题，尝试编辑你的 php.ini 文件，位置： /etc/php/7.0/apache2/php.ini ，在最后加上一行： 1extension=curl.so 安装 Git1sudo apt-get install git 修改网站根目录 http 在 /etc/apache2/sites-enabled/000-default.conf https 在 /etc/apache2/sites-enabled/001-ssl.conf 相关命令：1234sudo /etc/init.d/apache2 force-reload // 重新加载配置sudo /etc/init.d/apache2 start // 启动apache服务sudo /etc/init.d/apache2 restart // 重启apache服务sudo /etc/init.d/apache2 stop // 停止apache服务","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://laocaixw.github.io/tags/Web/"}]},{"title":"Sublime Text 3 插件及快捷键","slug":"Sublime_Text_3_Plugin_Key","date":"2017-08-27T13:30:00.000Z","updated":"2017-11-24T06:22:24.319Z","comments":true,"path":"2017/08/27/Sublime_Text_3_Plugin_Key/","link":"","permalink":"http://laocaixw.github.io/2017/08/27/Sublime_Text_3_Plugin_Key/","excerpt":"","text":"快捷键大全https://www.douban.com/note/362268947/ 插件Emmet代码自动生成工具。使用方法：输入缩写命令，按tab，自动生成代码。 如：! 自动生成html文档 参考文档：http://www.w3cplus.com/tools/emmet-cheat-sheet.html ConvertToUTF8字符编码工具 HTML-CSS-JS Prettify代码格式化工具 配置：http://www.cnblogs.com/yuanbo88/p/6065773.html Bracket Highlighter用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效 DocBlockrDocBlockr可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++ SideBarEnhancements侧边栏扩展 ColorHighlighter颜色显示 SublimeLinter代码检查 CodeFormatter代码格式化 MarkdownEditingMarkdown 语法高亮 OmniMarkupPreviewerMarkdown 实时预览。快捷键 Ctrl+Alt+O 在网页中打开预览；实时预览可能出现 404 错误，只要删除配置文件中 “extensions” 的 “strikeout” 即可。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://laocaixw.github.io/tags/工具/"}]},{"title":"Git命令","slug":"Git_Bash","date":"2017-08-17T03:00:00.000Z","updated":"2018-04-04T09:01:36.051Z","comments":true,"path":"2017/08/17/Git_Bash/","link":"","permalink":"http://laocaixw.github.io/2017/08/17/Git_Bash/","excerpt":"","text":"Git 的一些命令 git init将当前目录初始化为一个 git 仓库。 git status查看当前状态。 git add提交缓存。将修改添加到提交缓存中，只有 git commit 之后才算真正提交了。 12git add xxx // 只添加某个文件git add . // 添加所有修改 git commit提交。把 git add 好的代码提交待仓库。 1git add commit -m &quot;note&quot; // -m 表示注释，&quot;note&quot;就是注释内容 git log查看提交日志。就是 commit 的记录。 git reset撤销commit 1git reset --hard &lt;commit_id&gt; // &lt;commit_id&gt;表示commit的id，通过 git log 命令查看 git branch分支。 12git branch // 查看当前库里有几个分支，并且可以看到当前所在分支git branch dev // 创建 dev 分支 合并分支后，可以删除分支： 12git branch -d dev // 在主分支下执行，将 dev 分支删除git branch -D dev // 在主分支下执行，将 dev 分支强制删除 git checkout切换分支。创建分支后，当前所在分支还是之前的分支。 12git checkout dev // 切换到 dev 分支git checkout -b dev // 创建并切换到 dev 分支，一步到位 远程库分支相关 12git push --set-upstream origin dev // 将本地分支 dev 推送到远程库git checkout -b dev2 origin/dev // 创建一个本地分支 dev2 ，并与远程分支 dev 关联 git merge合并分支。 1git merge dev // 在主分支下执行，将 dev 分支合并到主分支上 git tag标签。可以给代码库打标签，如版本号。 1git tag v1.0 // 在代码库当前状态下，打上标签 v1.0 如果需要查看之前版本（标签）的代码，可以通过 git checkout v1.0 切换回原来标签位置的代码状态。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://laocaixw.github.io/tags/Git/"}]},{"title":"设计模式学习系列（4）--建造者模式","slug":"Design_Mode_4_Builder","date":"2017-08-11T02:30:00.000Z","updated":"2018-06-10T03:52:02.877Z","comments":true,"path":"2017/08/11/Design_Mode_4_Builder/","link":"","permalink":"http://laocaixw.github.io/2017/08/11/Design_Mode_4_Builder/","excerpt":"","text":"建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是由抽象建造负责规范产品的组成，由具体建造者负责实现产品各部分的具体方法，再由指挥者具体封装产品。 产品类 Product 1234567891011121314public class Product &#123; List&lt;String&gt; parts = new ArrayList&lt;&gt;(); public void addPart(String part) &#123; parts.add(part); &#125; public void show()&#123; System.out.println(\"Product:\"); for (String part : parts) &#123; System.out.println(part); &#125; &#125;&#125; 抽象建造者 Builder 12345678910public abstract class Builder &#123; // 设置产品的不同部分 public abstract void buildPart1(); public abstract void buildPart2(); public abstract void buildPart3(); // ... // 建造产品 public abstract Product getResult();&#125; 具体建造者 ConcreteBuilder 1234567891011121314151617181920212223242526public class ConcreteBuilder extends Builder &#123; private Product product = new Product(); // 设置产品的不同部分 @Override public void buildPart1() &#123; product.addPart(\"Part1\"); &#125; @Override public void buildPart2() &#123; product.addPart(\"Part2\"); &#125; @Override public void buildPart3() &#123; product.addPart(\"Part3\"); &#125; // ... // 建造产品 public Product getResult() &#123; return product; &#125;&#125; 指挥者 Director 1234567public class Director &#123; public void creat(Builder builder) &#123; builder.buildPart1(); builder.buildPart2(); builder.buildPart3(); &#125;&#125; 产品建造，客户不需要知道具体的建造过程 123456789public class Demo &#123; public static void main(String[] args) &#123; Director director = new Director(); Builder builder = new ConcreteBuilder(); director.creat(builder); Product product = builder.getResult(); product.show(); &#125;&#125; 生成的产品： 1234Product:Part1Part2Part3 用户可以按照不同的需求来构建产品，如果需要建造一个不同构成部件的产品，只要这样： 产品 2 的具体建造者 ConcreteBuilder2 1234567891011121314151617181920212223242526public class ConcreteBuilder2 extends Builder &#123; private Product product = new Product(); // 设置产品的不同部分 @Override public void buildPart1() &#123; product.addPart(\"Part1-型号A\"); &#125; @Override public void buildPart2() &#123; product.addPart(\"Part2-型号B\"); &#125; @Override public void buildPart3() &#123; product.addPart(\"Part3-型号C\"); &#125; // ... // 建造产品 public Product getResult() &#123; return product; &#125;&#125; 123456789public class Demo &#123; public static void main(String[] args) &#123; Director director = new Director(); Builder builder = new ConcreteBuilder2(); director.creat(builder); Product product = builder.getResult(); product.show(); &#125;&#125; 生成的产品： 1234Product:Part1-型号APart2-型号BPart3-型号C 建造者模式优点： 封装性良好，客户端可以不需要知道产品的具体构成细节，指挥者Director封装产品的建造过程，由具体建造者决定产品细节； 易于扩展，不同产品可以使用不同的具体建造者； 且不同具体建造者不会互相影响。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Android耗电分析","slug":"Android_Battery_Analysis","date":"2017-08-08T02:30:00.000Z","updated":"2018-04-04T07:53:13.099Z","comments":true,"path":"2017/08/08/Android_Battery_Analysis/","link":"","permalink":"http://laocaixw.github.io/2017/08/08/Android_Battery_Analysis/","excerpt":"","text":"Battery Historian 3开启 docker 服务： 1docker -- run -p &lt;port&gt;:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999 如： 1docker run -p 9999:9999 gcr.io/android-battery-historian/stable:3.0 --port 9999 耗电日志通过耗电日志就能看到系统对应用耗电的统计（估算值）。 导出日志： Android 7.0 and higher: 1adb bugreport bugreport.zip Android 6.0 and lower: 1adb bugreport &gt; bugreport.txt 重置系统耗电数据： 1adb shell dumpsys batterystats --reset 注：重置后一定要拔下 USB 线才会生效 日志说明batterystats 日志，耗电量估算项：Estimated power use (mAh) adb 命令 ps 可查看应用程序 Uid 参考Battery Historian 深入浅出Android App耗电量统计","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android反编译","slug":"Android_Decompile","date":"2017-08-03T02:30:00.000Z","updated":"2018-04-04T07:46:21.672Z","comments":true,"path":"2017/08/03/Android_Decompile/","link":"","permalink":"http://laocaixw.github.io/2017/08/03/Android_Decompile/","excerpt":"","text":"1. apktool将 apk 文件复制到 apktool ，进入 apktool 目录，执行反编译命令： 1apktool_2.2.4.jar d XXX.apk 反编译后，生成对应的 XXX 文件夹。 重新编译命令： 1apktool_2.2.4.jar b XXX 重新编译后，生成 build 、 dist 文件夹，build/apk 中会生成 dex 文件，新的 apk 文件在 dist 中。自己实际操作的时候，貌似没看到生成了 dist 文件夹？ 2. dex2jar将 dex 文件复制到 dex2jar 根目录下，进入 dex2jar 目录，执行： 1d2j-dex2jar.bat classes.dex 完成后，生成 jar 文件。 3. jd-gui最后，直接用 jd-gui 打开 jar 文件就可以查看代码了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android自定义View（3）事件机制","slug":"Android_Custom_View_3","date":"2017-08-01T13:00:00.000Z","updated":"2017-11-29T05:21:00.716Z","comments":true,"path":"2017/08/01/Android_Custom_View_3/","link":"","permalink":"http://laocaixw.github.io/2017/08/01/Android_Custom_View_3/","excerpt":"","text":"以 Activity 为最底层，View 为最顶层（底层 -&gt; 顶层： Activity -&gt; ViewGroup -&gt; View）。事件的分发是从底层到顶层传递，而事件的消费又是从顶层往底层传递。事件的分发过程可以通过 onInterceptTouchEvent 拦截。事件的消费过程中，返回 false 代表不消费事件，继续传递给下一层；而返回 true 代表消费掉事件，事件不再继续往下一层传递。 与事件相关组件包括 Activity、ViewGroup、View 等，与事件相关的方法有 dispatchTouchEvent、onInterceptTouchEvent、onTouch、onTouchEvent、onClick 等。其中 dispatchTouchEvent 负责分发事件；onInterceptTouchEvent 负责拦截事件；onTouchEvent会消费事件。 ActivitydispatchTouchEvent 分发事件，往 ViewGroup 分发事件； onTouchEvent 如果 ViewGroup 消费掉事件(返回 true)，则这里接收不到； ViewGroupdispatchTouchEvent 分发事件，往下一层 ViewGroup 或 View 分发事件； onInterceptTouchEvent 拦截事件，如果这层不希望该事件往下传递，而是让本层的 onTouch 消费，只需重写此方法并返回 true 即可； onTouch 如果返回 false，则事件会继续往 onTouchEvent 传递；如果返回 true，则表示事件被消费，不继续传递； onTouchEvent 如果下一层 ViewGroup 或 View 消费掉事件( 返回 true )，则这里接收不到； ViewdispatchTouchEvent 负责分发事件，往本层 onTouch 分发事件； onTouch 如果返回 false，则事件会继续往 onTouchEvent 传递；如果返回 true，则表示事件被消费，不继续传递； onTouchEvent 如果下一层 ViewGroup 或 View 消费掉事件( 返回 true )，则这里接收不到； 事件传递图以触摸事件为例。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android自定义View（2）测量布局绘制","slug":"Android_Custom_View_2","date":"2017-07-22T02:00:00.000Z","updated":"2017-11-29T05:19:24.683Z","comments":true,"path":"2017/07/22/Android_Custom_View_2/","link":"","permalink":"http://laocaixw.github.io/2017/07/22/Android_Custom_View_2/","excerpt":"","text":"一、 测量 onMeasure(widthMeasureSpec, heightMeasureSpec)MeasureSpec 是测量规格，里面包含了模式和尺寸，测量模式有一下三种： MeasureSpec.EXACTLY 精确模式。当宽高指定大小、或者指定为 match_parent 时。 MeasureSpec.AT_MOST 最大值模式。当宽高指定为 wrap_content 时。此时控件大小一般随子控件或内容而变化。 MeasureSpec.UNSPECIFIED 不指定大小测量模式，想多大就多大。 View 类默认 onMeasure 方法只支持EXACTLY模式，因此想要支持 wrap_content 就必须重写 onMeasure 方法来指定 wrap_content 时的大小。 以测量宽度为例： 1234567891011121314151617181920@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));&#125;private int measureWidth(int widthMeasureSpec) &#123; int result; int specMode = MeasureSpec.getMode(widthMeasureSpec); int specSize = MeasureSpec.getSize(widthMeasureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = 200; if (specMode == MeasureSpec.AT_MOST) &#123; result = Math.min(result, specSize); &#125; &#125; return result;&#125; 测量后调用 setMeasuredDimension(); 来保存测量后的尺寸。 ViewGroup 的测量ViewGroup 的测量，是通过遍历所有子 View，从而调用子 View 的 measure 方法来获得所有子 View 的测量结果，再根据 ViewGroup 的需求来计算出 ViewGroup 的尺寸，从而完成 ViewGroup 的测量。 二、 布局 onLayout(changed, left, top, right, bottom)测量完成后，会进行 Layout 过程，将子 View 放在合适的位置。 一般来说，自定义 View 没有子 View，所以是不用实现 Layout 过程的，有子 View 的 ViewGroup 才需要通过 Layout 过程来正确地摆放子 View。 ViewGroup 的布局ViewGroup 的布局，是通过遍历所有的子 View，根据 ViewGroup 的需求计算出它们的位置，最后调用它们的 layout() 来确定每个子 View 的位置。 三、 绘制 onDraw(canvas)通常，绘制 View 的 onDraw() 方法中会有一个 Canvas 对象，使用这个 Canvas 对象就可以进行绘图了。而如果在其他地方则需要创建一个 Canvas 对象，一般会通过 bitmap 创建，这样绘制的效果会作用在这个 bitmap 上。 1Canvas canvas = new Canvas(bitmap); 绘制的过程比较简单，一般需要画什么形状，就调用 Canvas 的相应方法。具体的形状和位置，都是数学问题。 ViewGroup 的绘制ViewGroup 通常不需要绘制，但是会调用 dispatchDraw 方法来绘制子 View ，其过程也是通过遍历子 View ，调用子 View 的 onDraw 方法来完成工作。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android自定义View（1）官网教程","slug":"Android_Custom_View_1","date":"2017-07-15T02:00:00.000Z","updated":"2017-11-29T05:19:13.780Z","comments":true,"path":"2017/07/15/Android_Custom_View_1/","link":"","permalink":"http://laocaixw.github.io/2017/07/15/Android_Custom_View_1/","excerpt":"","text":"概括一下官网的教程。 一、创建一个自定义 view 类1. 新建一个类继承 view12345class PieChart extends View &#123; public PieChart(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125;&#125; 2. 定义自定义属性在 res/values/attrs.xml 中增加 资源，加入 showText 和 labelPosition 两个属性： 123456789&lt;resources&gt; &lt;declare-styleable name=\"PieChart\"&gt; &lt;attr name=\"showText\" format=\"boolean\" /&gt; &lt;attr name=\"labelPosition\" format=\"enum\"&gt; &lt;enum name=\"left\" value=\"0\"/&gt; &lt;enum name=\"right\" value=\"1\"/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在布局在使用自定义属性，需要先添加命名空间 http://schemas.android.com/apk/res/[your package name] 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:custom=\"http://schemas.android.com/apk/res/com.example.customviews\"&gt; &lt;com.example.customviews.charting.PieChart custom:showText=\"true\" custom:labelPosition=\"left\" /&gt;&lt;/LinearLayout&gt; 3. 应用自定义属性在代码中可以读取自定义属性 1234567891011121314public PieChart(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray a = context.getTheme().obtainStyledAttributes( attrs, R.styleable.PieChart, 0, 0); try &#123; mShowText = a.getBoolean(R.styleable.PieChart_showText, false); mTextPos = a.getInteger(R.styleable.PieChart_labelPosition, 0); &#125; finally &#123; a.recycle(); &#125;&#125; 最后一定要回收 TypedArray 4. 添加属性和事件将自定义 view 的属性暴露出来 123456789public boolean isShowText() &#123; return mShowText;&#125;public void setShowText(boolean showText) &#123; mShowText = showText; invalidate(); requestLayout();&#125; 使用 invalidate() 和 requestLayout() 来确保 view 被刷新 自定义 view 也支持事件监听 5. 无障碍设计官方建议，自定义 View 应该支持最广泛的用户，包括有残疾障碍的用户。为了支持残障用户，应该这样做： 使用 android:contentDescription 属性 适当地调用 sendAccessibilityEvent() 来发送辅助功能事件 支持备用控制器，如 D-pad 和 轨迹球 二、自定义画图1. 创建画布和画笔在构造函数中调用初始化函数 12345678910111213141516171819private void init() &#123; mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mTextPaint.setColor(mTextColor); if (mTextHeight == 0) &#123; mTextHeight = mTextPaint.getTextSize(); &#125; else &#123; mTextPaint.setTextSize(mTextHeight); &#125; mPiePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPiePaint.setStyle(Paint.Style.FILL); mPiePaint.setTextSize(mTextHeight); mShadowPaint = new Paint(0); mShadowPaint.setColor(0xff101010); mShadowPaint.setMaskFilter(new BlurMaskFilter(8, BlurMaskFilter.Blur.NORMAL)); ...&#125; 在 onDraw() 中创建画布和画笔会明显降低性能 2. 处理布局事件如果要简单地控制 view，只需要重写 onSizeChanged()。view 首次分配尺寸或者尺寸被改变时，都会调用 onSizeChanged()。计算 view 的各种尺寸应该在 onSizeChanged() 里，而不是在每次 draw 的时候。 1234567891011121314151617@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); // Account for padding float xpad = (float)(getPaddingLeft() + getPaddingRight()); float ypad = (float)(getPaddingTop() + getPaddingBottom()); // Account for the label if (mShowText) xpad += mTextWidth; float ww = (float)w - xpad; float hh = (float)h - ypad; // Figure out how big we can make the pie. float diameter = Math.min(ww, hh);&#125; 如果要更好地控制 view，需要重写 onMeasure()，该方法的参数 View.MeasureSpec 会告诉你，父 View 希望这个控件是什么样的尺寸、是固定的或者只是一个建议。按照父 view 的尺寸要求来控制 view。 12345678910111213@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Try for a width based on our minimum int minw = getPaddingLeft() + getPaddingRight() + getSuggestedMinimumWidth(); int w = resolveSizeAndState(minw, widthMeasureSpec, 1); // Whatever the width ends up being, ask for a height that would let the pie // get as big as it can int minh = MeasureSpec.getSize(w) - (int)mTextWidth + getPaddingBottom() + getPaddingTop(); int h = resolveSizeAndState(MeasureSpec.getSize(w) - (int)mTextWidth, heightMeasureSpec, 0); setMeasuredDimension(w, h);&#125; resolveSizeAndState() 通过对比父 view 的要求，来确定最终的长和宽。最后必须调用 setMeasuredDimension() 来设置尺寸。 3. 重写 onDraw()，画图1234567891011121314151617181920212223242526protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // Draw the shadow canvas.drawOval( mShadowBounds, mShadowPaint ); // Draw the label text canvas.drawText(mData.get(mCurrentItem).mLabel, mTextX, mTextY, mTextPaint); // Draw the pie slices for (int i = 0; i &lt; mData.size(); ++i) &#123; Item it = mData.get(i); mPiePaint.setShader(it.mShader); canvas.drawArc(mBounds, 360 - it.mEndAngle, it.mEndAngle - it.mStartAngle, true, mPiePaint); &#125; // Draw the pointer canvas.drawLine(mTextX, mPointerY, mPointerX, mPointerY, mTextPaint); canvas.drawCircle(mPointerX, mPointerY, mPointerSize, mTextPaint);&#125; 三、使用视图交互1. 处理手势输入例如，Android 里最普通的事件是 touch 事件，重写 onTouchEvent() : 1234@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; return super.onTouchEvent(event);&#125; GestureDetector 可以将原生的 touch 事件转化为手势事件。你只要写一个类实现 GestureDetector.OnGestureListener 接口，就可以监听用户的手势事件，如果你只需要监听少数的几个手势事件，也可以写一个类继承 GestureDetector.SimpleOnGestureListener 类。例如： 1234567class mListener extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onDown(MotionEvent e) &#123; return true; &#125;&#125;mDetector = new GestureDetector(PieChart.this.getContext(), new mListener()); 无论是否使用 GestureDetector.SimpleOnGestureListener，都必须实现 onDown() 方法，并返回 true，因为所有是手势事件都是从一个 onDown 事件开始的，如果返回了 false，系统会认为你忽略了这个手势，而且 GestureDetector.OnGestureListener 的其他方法都不会被调用。只有你真的需要忽略这个手势，才可以返回 false。 如果你需要用 GestureDetector 来监听用户的手势，你应该在 onTouch 中接收触摸事件： 1234567891011@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; boolean result = mDetector.onTouchEvent(event); if (!result) &#123; if (event.getAction() == MotionEvent.ACTION_UP) &#123; stopScrolling(); result = true; &#125; &#125; return result;&#125; 如果 GestureDetector 的 onTouchEvent 返回了 false，说明它忽略了这个 touch 事件，那么你可以 GestureDetector 外按需处理这个事件。 2. 创建物理上合理的运动如果要正确地模拟物理惯性，需要大量的物理和数学知识，Android 提供了 Scroller 类来帮助我们实现它。将 GestureDetector 获取到的 onFling 事件交给 Scroller 处理： 12345@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; mScroller.fling(currentX, currentY, velocityX / SCALE, velocityY / SCALE, minX, minY, maxX, maxY); postInvalidate();&#125; 很多开发者觉得直接用 fling 的速度值，滑动动画会太快了，一般需要将 x 和 y 方向的速度减少 4 到 8 倍。 之后，你需要通过 Scroller.computeScrollOffset() 及时更新 Scroller。大多数 View 通过 Scroller 直接调用 scrollTo() 滚动到指定位置，但是 PieChart 例子不太一样，它通过 y 方向的滚动位置来设置旋转角度： 1234if (!mScroller.isFinished()) &#123; mScroller.computeScrollOffset(); setPieRotation(mScroller.getCurrY());&#125; Scroller 类计算完位置后，不会去更新你的 View，你需要自己去更新它，通常有两种办法： 在调用完 fling() 后，调用 postInvalidate() 刷新 View。 使用动画 ValueAnimator，并且通过 addUpdateListener() 添加一个监听器。 PieChart 例子就是用了第二种方法，它用起来稍微复杂点，但它更有效率并且避免了不必要的重绘，缺点就是需要 API Level 11 才有 ValueAnimator。 1234567891011121314mScroller = new Scroller(getContext(), null, true);mScrollAnimator = ValueAnimator.ofFloat(0,1);mScrollAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; if (!mScroller.isFinished()) &#123; mScroller.computeScrollOffset(); setPieRotation(mScroller.getCurrY()); &#125; else &#123; mScrollAnimator.cancel(); onScrollFinished(); &#125; &#125;&#125;); 3. 平滑过渡Android 3.0 开始有提供 Animator，ValueAnimator 可以使 View 平滑的变化，而不是突然地改变它的位置或形状。 1234mAutoCenterAnimator = ObjectAnimator.ofInt(PieChart.this, \"PieRotation\", 0);mAutoCenterAnimator.setIntValues(targetAngle);mAutoCenterAnimator.setDuration(AUTOCENTER_ANIM_DURATION);mAutoCenterAnimator.start(); 使用 ViewPropertyAnimator 可以同时执行多个动画。 1animate().rotation(targetAngle).setDuration(ANIM_DURATION).start(); 4. 优化 View 不要再 onDraw 里做内存分配的操作，应该在初始化的时候做。 减少 onDraw 的调用次数，即减少 invaildate() 的调用次数；尽量用带 4 个参数的 invaildate()，少用无参数的 invaildate()。 减少 requestLayout() 的调用。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"获取双卡双待手机SIM卡信息","slug":"Android_DualCard_SIM","date":"2017-06-14T02:30:00.000Z","updated":"2017-11-18T15:32:47.209Z","comments":true,"path":"2017/06/14/Android_DualCard_SIM/","link":"","permalink":"http://laocaixw.github.io/2017/06/14/Android_DualCard_SIM/","excerpt":"","text":"使用反射遍历 TelephonyManager 中的方法，通过肉眼基本能找到获取双卡双待号码的方法，最后通过反射取到 SIM 卡信息。 12345678910111213141516171819202122232425262728293031323334353637// 遍历 TelephonyManager 里的方法public void printTelephonyManagerMethodNamesForThisDevice() &#123; TelephonyManager telephony = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE); Class&lt;?&gt; telephonyClass; try &#123; telephonyClass = Class.forName(telephony.getClass().getName()); Method[] methods = telephonyClass.getMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; Log.i(TAG, &quot;\\n&quot; + methods[i] + &quot; declared by &quot; + methods[i].getDeclaringClass()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;// 获取双卡双待 SIM 卡序列号public void getSubscriberId() &#123; TelephonyManager telephony = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE); Class&lt;?&gt; telephonyClass; Object result = null; Object result0 = null; Object result1 = null; try &#123; telephonyClass = Class.forName(telephony.getClass().getName()); Method m1 = telephonyClass.getMethod(&quot;getSubscriberId&quot;); Method m2 = telephonyClass.getMethod(&quot;getSubscriberId&quot;, new Class[]&#123;int.class&#125;); result = m1.invoke(telephony); result0 = m2.invoke(telephony, 0); result1 = m2.invoke(telephony, 1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Log.i(TAG, &quot; getSubscriberId : &quot; + telephony.getSubscriberId() + &quot;\\n&quot; + &quot; result : &quot; + result + &quot;\\n&quot; + &quot; result0 : &quot; + result0 + &quot;\\n&quot; + &quot; result1 : &quot; + result1 + &quot;\\n&quot;);&#125; 是否能取到手机号，取决于手机卡，而大部分手机卡都取不到手机号码，只能取到 SIM 卡序列号。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"多渠道打包","slug":"Android_MultiChannel_APK","date":"2017-06-11T02:00:00.000Z","updated":"2017-11-16T13:30:42.280Z","comments":true,"path":"2017/06/11/Android_MultiChannel_APK/","link":"","permalink":"http://laocaixw.github.io/2017/06/11/Android_MultiChannel_APK/","excerpt":"","text":"这段时间，公司项目集成了第三方行为分析 SDK ，并且希望对各个渠道的信息做一些统计，这就必然会设计到多渠道打包。 多渠道打包思路其实也很简单，通过 Gradle 配置修改 Manifest 中 meta-data 的值，这样打包生成的多个包中 meta-data 就可以不一样，在代码中获取到不同的 meta-data 值，由此来区分不同的渠道。 1.配置 Gradle在项目主工程的 build.gradle 中，添加如下配置： 12345678910111213android &#123; productFlavors &#123; xiaomi &#123; manifestPlaceholders = [CHANNEL_VALUE: \"xiaomi\"] &#125; tencent &#123; manifestPlaceholders = [CHANNEL_VALUE: \"tencent\"] &#125; baidu &#123; manifestPlaceholders = [CHANNEL_VALUE: \"baidu\"] &#125; ...&#125; 这里的 CHANNEL_VALUE 是后面 Manifest 中对应的值。如果一个项目要在 meta-data 中配多个参数，每增加一个渠道难免会多写很多行代码，可以参考下面的简便写法： 1234567891011android &#123; productFlavors &#123; xiaomi &#123;&#125; tencent &#123;&#125; baidu &#123;&#125; ... &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [CHANNEL_VALUE: name] &#125;&#125; 这样写可以直接把 productFlavors 的 name 配到 meta-data 中。 2.配置 Manifest在 Manifest 的 application 下配置 meta-data ，如下： 12345678910111213&lt;application android:name=\"...\" android:icon=\"...\" android:label=\"...\"&gt; &lt;meta-data android:name=\"channel_value\" android:value=\"$&#123;CHANNEL_VALUE&#125;\" /&gt; &lt;activity android:name=\"...\" android:label=\"...\" /&gt; ...&lt;/application&gt; 这里的 CHANNEL_VALUE 就会被赋值为上面 gradle 中配的 name（CHANNEL_VALUE: name），而 channel_value 可以在 java 中获取到。 3.获取 meta-data 值在 java 中可以获取到 meta-data 配置的值，通过这个值，我们就可以区分不同的渠道信息了。 12345678String channelValue = \"\";try &#123; ApplicationInfo appInfo = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA); channelValue = appInfo.metaData.getString(\"channel_value\");&#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace();&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android方法数超限问题探究与启动优化","slug":"Android_MultiDex","date":"2017-05-15T12:00:00.000Z","updated":"2018-04-06T06:37:55.349Z","comments":true,"path":"2017/05/15/Android_MultiDex/","link":"","permalink":"http://laocaixw.github.io/2017/05/15/Android_MultiDex/","excerpt":"","text":"前段时间写了篇有关Eclipse工程转Android Studio工程的文章，而导致公司项目需要转 AS 的直接原因，就是今天要写的主题–方法数超限，相信大多数 Android 项目的都会碰到这个问题。 传统的 Eclipse 解决方法数超限的办法，就是在 project.properties 中加上 dex.force.jumbo=true ，然后清理工程重新编译。但是，当方法数越来越多，这个方法也会解决不了问题，这个时候，就要用到 Google 官方给出的方案 MultiDex 了。 MultiDex 解决方案一、 如果你的 minSdkVersion &gt;= 21 ，那么只要在模块的 build.gradle 中添加： 1234567android &#123; defaultConfig &#123; ... multiDexEnabled true &#125; ...&#125; 二、 如果你的 minSdkVersion &lt; 21 ，那么只要在模块的 build.gradle 中添加： 1234567891011android &#123; defaultConfig &#123; ... multiDexEnabled true &#125; ...&#125;dependencies &#123; compile 'com.android.support:multidex:1.0.1'&#125; 然后，如果你没有写自己的 Application 类，那么你只要写上自己的 Application 类，并继承 MultiDexApplication ；如果你写过自己的 Application 类，并且/或者不希望 Application 类继承 MultiDexApplication ，那么你需要重写 Application 的 attachBaseContext 方法： 12345@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(context); Multidex.install(this);&#125; 启动优化官方的解决方案虽然简单，但是也存在一定的局限。比如，首次加载应用时，由于需要加载 DEX 文件，会消耗较多的时间，导致启动速度慢，影响用户体验，甚至很可能引发 ANR 。 针对加载 Dex 问题，美团技术团队是这样做的：精简主 Dex 包，应用启动起来后再异步加载第二个 Dex 包。这是一个很不错的想法，但是实现起来有一定的难度。需要编写脚本，区分哪些类要放在主 Dex 包中，而且一般项目中都会用到很多第三方 SDK，这很可能导致主 Dex 包的精简程度不能达到我们想要的状态。 当然，除此之外，还有更适合我们的方案，微信开发团队的解决思路就很有意思，他们逆了不少 APP，最后参考并改进了 Facebook 的解决方案。大概的思路就是，新开一个进程来执行 Multidex.install() 方法。 微信开发团队的思路实现起来也比较简单，下面直接上我的代码（顺便把启动体验也优化了~）： Application 中的 attachBaseContext 方法： 123456789@Overrideprotected void attachBaseContext(Context context) &#123; super.attachBaseContext(context); if (MultiDexUtils.isMainProcess(context)) &#123; // 判断是否是主进程，避免重复执行 MultiDexUtils.setMainActivityStarted(this, false); // 保存本地数据，标记主页面是否已经开启 MultiDexUtils.setLoadDexActivityClosed(this, false); // 保存本地数据，标记加载Dex进程是否已经关闭 MultiDexUtils.startLoadDexActivity(context); // 打开加载 Dex 的进程页面，这样我们的APP就变成后台进程了 &#125;&#125; 加载 Dex 的进程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class LoadDexActivity extends Activity &#123; private static final int MULTIDEX_ERROR = 0; private static final int MULTIDEX_ACTIVITY_STARTED = 1; Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MULTIDEX_ERROR: case MULTIDEX_ACTIVITY_STARTED: // 退出当前进程 MultiDexUtils.setLoadDexActivityClosed(getApplication()); finish(); System.exit(0); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_loaddex); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; new Thread() &#123; @Override public void run() &#123; Message message = handler.obtainMessage(); long startTime = System.currentTimeMillis(); long timeout = 10 * 1000; // 加载超时时间 try &#123; MultiDex.install(getApplication()); Thread.sleep(500); // 等待主界面启动 while (!MultiDexUtils.isMainActivityStarted(getApplication()) &amp;&amp; (System.currentTimeMillis() - startTime) &lt; timeout) &#123; Thread.sleep(200); &#125; message.what = MULTIDEX_ACTIVITY_STARTED; handler.sendMessage(message); &#125; catch (Exception e) &#123; message.what = MULTIDEX_ERROR; handler.sendMessage(message); &#125; &#125; &#125;.start(); &#125; @Override public void onBackPressed() &#123; //cannot backpress &#125;&#125; Manifest 中 LoadDexActivity 的配置： 12345678&lt;activity android:name=\".LoadDexActivity\" android:alwaysRetainTaskState=\"false\" android:excludeFromRecents=\"true\" android:launchMode=\"singleTask\" android:process=\":loadDex\" android:screenOrientation=\"portrait\"&gt;&lt;/activity&gt; 主界面 onCreate 方法： 1234567@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ... MultiDexUtils.setMainActivityStarted(getApplication()); // 告诉loadDex进程，主界面已启动 ...&#125; MultiDexUtils 工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class MultiDexUtils &#123; public static final String KEY_ACTIVITY_STARTED = \"activity-started-\"; public static final String KEY_LOADDEX_CLOSED = \"loaddex-closed-\"; /** * 当前进程是否是主进程 */ public static boolean isMainProcess(Context context) &#123; return \"com.***.***(进程名一般是包名)\".equals(getCurProcessName(context)); &#125; /** * 设置-主界面已经打开 */ public static void setMainActivityStarted(Context context) &#123; setMainActivityStarted(context, true); &#125; /** * 设置-主界面是否已经打开 */ public static void setMainActivityStarted(Context context, boolean b) &#123; SharedPreferences sp = context.getSharedPreferences(\"multidex\", Context.MODE_MULTI_PROCESS); sp.edit().putBoolean(KEY_ACTIVITY_STARTED + getPackageInfo(context).versionCode, b).commit(); &#125; /** * 是否需要等待主界面 */ public static boolean isMainActivityStarted(Context context) &#123; SharedPreferences sp = context.getSharedPreferences(\"multidex\", Context.MODE_MULTI_PROCESS); return sp.getBoolean(KEY_ACTIVITY_STARTED + getPackageInfo(context).versionCode, false); &#125; /** * 判断加载页面是否关闭 */ public static boolean isLoadDexActivityClosed(Context context) &#123; SharedPreferences sp = context.getSharedPreferences(\"multidex\", Context.MODE_MULTI_PROCESS); return sp.getBoolean(KEY_LOADDEX_CLOSED + getPackageInfo(context).versionCode, false); &#125; /** * 设置加载页面已经关闭 */ public static void setLoadDexActivityClosed(Context context) &#123; setLoadDexActivityClosed(context, true); &#125; /** * 设置-加载页面是否已经关闭 */ public static void setLoadDexActivityClosed(Context context, boolean b) &#123; SharedPreferences sp = context.getSharedPreferences(\"multidex\", Context.MODE_MULTI_PROCESS); sp.edit().putBoolean(KEY_LOADDEX_CLOSED + getPackageInfo(context).versionCode, b).commit(); &#125; /** * 开启等待页面，新的进程 */ public static void startLoadDexActivity(Context context) &#123; Intent intent = new Intent(); ComponentName componentName = new ComponentName(\"com.***.***(包名)\", LoadDexActivity.class.getName()); intent.setComponent(componentName); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; /** * 获取进程名 */ public static String getCurProcessName(Context context) &#123; try &#123; int pid = android.os.Process.myPid(); ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); for (ActivityManager.RunningAppProcessInfo appProcess : mActivityManager.getRunningAppProcesses()) &#123; if (appProcess.pid == pid) &#123; return appProcess.processName; &#125; &#125; &#125; catch (Exception e) &#123; // ignore &#125; return null; &#125; /** * 获取包信息 */ private static PackageInfo getPackageInfo(Context context) &#123; PackageManager pm = context.getPackageManager(); try &#123; return pm.getPackageInfo(context.getPackageName(), 0); &#125; catch (PackageManager.NameNotFoundException e) &#123;// Log.i(TAG, e.getLocalizedMessage()); &#125; return new PackageInfo(); &#125;&#125; 另一种启动优化方案还有一种简单的启动优化方案，只能优化启动体验，并不能解决 ANR 问题。 在点击桌面图标启动应用时，给个背景图片，启动完成后，将背景设回空。 1.在入口 Activity 中加入主题背景 1android:theme=&quot;@style/SplashTheme&quot; style.xml 中加入配置： value: 123&lt;style name=&quot;SplashTheme&quot; parent=&quot;@android:style/Theme.NoTitleBar&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@drawable/logo_splash&lt;/item&gt;&lt;/style&gt; value-v21:(解决21版本及以上的过度动画效果问题) 123&lt;style name=&quot;SplashTheme&quot; parent=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/logo_splash&lt;/item&gt;&lt;/style&gt; 2.将背景设回原样 1234@Overridepublic void setTheme(int resid) &#123; super.setTheme(R.style.CustomTransparent);&#125; style.xml 配置如下： 1234&lt;style name=&quot;CustomTransparent&quot; parent=&quot;@android:style/Theme.Translucent&quot;&gt; &lt;item name=&quot;android:background&quot;&gt;@null&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/curve_floater_frameColor&lt;/item&gt;&lt;/style&gt; 参考其实你不知道 MultiDex 到底有多坑 美团 Android DEX 自动拆包及动态加载简介 Android 拆分与加载 Dex 的多种方案对比 配置方法数超过 64K 的应用","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Android权限申请","slug":"Android_Permission_Apply","date":"2017-05-12T02:00:00.000Z","updated":"2018-04-04T07:54:56.882Z","comments":true,"path":"2017/05/12/Android_Permission_Apply/","link":"","permalink":"http://laocaixw.github.io/2017/05/12/Android_Permission_Apply/","excerpt":"","text":"Android 6.0 变化Android 6.0 (API23) 对权限系统做了一些变化，引入了一种新的权限模式–运行时权限。 Android 6.0 之后，权限分为两类：正常权限和危险权限。正常权限一般不涉及用户隐私，只要在 manifest 中声明了之后，系统会自动授予该权限；而危险权限在声明了之后，还需要向用户申请，只有用户同意才会授予该权限。正常权限和危险权限。 权限申请下面来看看具体怎么申请，以申请短信权限为例。 1.声明第一步肯定还是需要在 manifest 中声明。 1&lt;uses-permission android:name=\"android.permission.SEND_SMS\"/&gt; 2.检查权限1ContextCompat.checkSelfPermission(SMSActivity.this, Manifest.permission.SEND_SMS) 返回 “PackageManager.PERMISSION_GRANTED” 表示已经授权可用，返回 “PackageManager.PERMISSION_DENIED” 表示需要申请授权。 3.申请授权1ActivityCompat.requestPermissions(SMSActivity.this, new String[]&#123;Manifest.permission.SEND_SMS&#125;, REQUEST_CODE_PERMISSION_SEND_SMS); 第一个参数是 context ；第二个参数是需要申请的权限字符串数组，支持一次性申请多个权限；第三个是请求码，下一步的回调中会看到。 4.权限申请回调用户允许或拒绝之后，会执行回调。 12345678910111213@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case REQUEST_CODE_PERMISSION_SEND_SMS: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // 用户同意授权，可以执行你要的操作了 sendTextSMS(phoneNum, content); &#125; break; ... &#125;&#125; 5.拒绝后再申请如果用户上一次已经拒绝过你的权限，但是某个操作仍然需要授权，那么你又得弹出授权框。这个时候你需要给用户一个解释，为什么需要这个授权。这种情况下就可以调用以下接口。 1234if (ActivityCompat.shouldShowRequestPermissionRationale(SMSActivity.this, Manifest.permission.SEND_SMS)) &#123; &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"设计模式学习系列（3）--抽象工厂模式","slug":"Design_Mode_3_AbstractFactory","date":"2017-04-17T02:30:00.000Z","updated":"2018-06-10T03:51:55.254Z","comments":true,"path":"2017/04/17/Design_Mode_3_AbstractFactory/","link":"","permalink":"http://laocaixw.github.io/2017/04/17/Design_Mode_3_AbstractFactory/","excerpt":"","text":"抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。 工厂方法模式回顾设计模式学习系列（2）–工厂方法模式 上一篇学习了工厂方法模式： 定义产品和工厂的接口 具体产品/工厂分别实现它们的接口 实例化的时候，实例化它们的具体类；而在调用的时候，只要调用它们的父类（接口）就行了 后续维护的时候，如果增加或修改了产品，那么只需要改动实例化的地方就可以了。 如果遇到产品等级结构是多个的时候，就需要用到抽象工厂模式了。 抽象工厂模式以上一篇留下的鼠标品牌和类型两个产品等级为例： 产品:A品牌接口 123public interface ProductA &#123; public void method();&#125; B品牌接口 123public interface ProductB &#123; public void method();&#125; A品牌 1类型 12345public class ProductA1 implement ProductA &#123; public void method() &#123; // 产品A1方法 &#125;&#125; A品牌 2类型 12345public class ProductA2 implement ProductA &#123; public void method() &#123; // 产品A2方法 &#125;&#125; B品牌 1类型 12345public class ProductB1 implement ProductB &#123; public void method() &#123; // 产品B1方法 &#125;&#125; B品牌 2类型 12345public class ProductB2 implement ProductB &#123; public void method() &#123; // 产品B2方法 &#125;&#125; 工厂:工厂接口类 1234public interface Factory &#123; public ProductA createProductA(); // 生产品牌A的产品 public ProductB createProductB(); // 生产品牌B的产品&#125; 具体工厂1 12345678910public class Factory1 implement Factory &#123; public ProductA createProductA() &#123; // 生产产品A1 return new ProductA1(); &#125; public ProductB createProductB() &#123; // 生产产品B1 return new ProductB1(); &#125;&#125; 具体工厂2 12345678910public class Factory2 implement Factory &#123; public ProductA createProductA() &#123; // 生产产品A2 return new ProductA2(); &#125; public ProductB createProductB() &#123; // 生产产品B2 return new ProductB2(); &#125;&#125; 客户端 123456789public class Demo &#123; public static void main(String[] args) &#123; Factory factory = new Factory1(); // Factory factory = new Factory2(); ProductA product = factory.createProductA(); // ProductB product = factory.createProductB(); product.method(); &#125;&#125; 抽象工厂模式是工厂方法模式的进一步抽象，针对这种多产品等级结构非常合适，如果要扩展一个品牌 C，只需增加对应的产品和工厂就行了。这种模式虽然好，但也是存在缺点的，例如需要增加产品类型，则需要修改多个接口，影响现有的工厂类。所以在代码设计的过程中，还是要依据实际情况来，设计模式只是提供了几个方法和思路，具体怎么设计，还是要遵循那六个设计原则来（单一职责原则、里式替换原则、依赖倒置原则、接口隔离原则、迪米特法则、开闭原则）。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"设计模式学习系列（2）--工厂方法模式","slug":"Design_Mode_2_Factory","date":"2017-04-14T02:30:00.000Z","updated":"2018-06-10T03:51:40.454Z","comments":true,"path":"2017/04/14/Design_Mode_2_Factory/","link":"","permalink":"http://laocaixw.github.io/2017/04/14/Design_Mode_2_Factory/","excerpt":"","text":"工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。 简单工厂模式说工厂方法模式之前，我们先来说说简单的工厂模式。 简单工厂模式中，一个工厂类处于对产品实例化的中心位置上，它知道每一个产品，它决定哪一个产品应该被实例化。 比如，现在我们需要生产一个产品 A 和产品 B： 产品接口 123public interface Product &#123; public void method();&#125; 产品A 12345public class ProductA implement Product &#123; public void method() &#123; // 产品A方法 &#125;&#125; 产品B 12345public class ProductB implement Product &#123; public void method() &#123; // 产品B方法 &#125;&#125; 工厂类 123456789public class Factory &#123; public static Product createProduct(String productType) &#123; if(\"A\".equals(productType)) &#123; return new ProductA(); &#125; else if(\"B\".equals(productType)) &#123; return new ProductB(); &#125; &#125;&#125; 客户端 1234567public class Demo &#123; public static void main(String[] args) &#123; Product product = Factory.createProduct(\"A\"); // Product product = Factory.createProduct(\"B\"); product.method(); &#125;&#125; 当我们需要改变 Product 的时候，只要 Factory.createProduct(String type) 传入不同的 type 就可以了，不要去修改 product ，非常方便。当然，这个模式也存在不足，当我们需要加一个 ProductC 的时候，还要去修改 Factory 类，这明显违反了开闭原则，由这里就引申出了工厂方法模式。 工厂方法模式工厂方法模式其实就是在简单工厂模式基础上进一步抽象，把 Factory 也用接口来实现。 工厂接口 123public interface Factory &#123; public Product createProduct();&#125; 具体工厂A 123456public class FactoryA implement Factory &#123; public Product createProduct() &#123; // 生产产品A return new ProductA(); &#125;&#125; 具体工厂B 123456public class FactoryB implement Factory &#123; public Product createProduct() &#123; // 生产产品B return new ProductB(); &#125;&#125; 客户端 12345678public class Demo &#123; public static void main(String[] args) &#123; Factory factory = new FactoryA(); // Factory factory = new FactoryB(); Product product = factory.createProduct(); product.method(); &#125;&#125; 当我们需要加一个 ProductC 的时候，只要再加一个 FactoryC 就可以了。这样明显是符合开闭原则，非常方便。 工厂方法模式在目前我们讨论的一个产品等级结构中是很方便的，如果现在产品等级结构是多个呢，ProductA1、ProductA2、ProductB1、ProductB2。这样说产品等级结构可能不太好理解，其实就是一个二维数组，举个例子：现在需要生产鼠标，鼠标品牌有 A 和 B，这是第一个等级；鼠标类型是 1、2、3 等，这是第二个产品等级；等等。如果按 A+1、A+2、A+3、B+1… 这样来写 Product ，岂不是要写很多出来，那应该怎么做呢？这就可以再引申到抽象工厂模式了，下一篇继续学。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Eclipse工程转Android Studio工程","slug":"Eclipse_Convert_Android_Studio","date":"2017-02-28T08:40:00.000Z","updated":"2018-04-04T08:30:37.753Z","comments":true,"path":"2017/02/28/Eclipse_Convert_Android_Studio/","link":"","permalink":"http://laocaixw.github.io/2017/02/28/Eclipse_Convert_Android_Studio/","excerpt":"","text":"目前，用 Android Studio 来开发 Android 项目已是大势所趋，就连 Google 也已经宣布了不再支持 Eclipse 。所以一些老的 Eclipse 工程转 Android Studio 工程也是有必要的。工程转换有两种：一种是兼容模式，即 Eclipse 和 Android Studio 都可以用的工程结构；一种是 Android Studio 的目录结构。这里先记录下兼容模式的转换方法。 一.从 Eclipse 中导出 Gradle 文件首先保证 Eclipse 包含 Gradle 插件，选择菜单 File-&gt;Export-&gt;Generate Gradle build files， 然后一路无脑 next ，勾选需要转换的工程（如果有依赖工程，把依赖工程也勾选上），在 finish 之前最好勾选上 Force overriding of existing files ，以保证覆盖掉工程中由于之前有过类似操作而存在的文件。 二.修改 gradle 文件参数现在，工程中多出了几个 gradle 相关的文件。修改两个地方为最新版本： build.gradle。 找到 1classpath 'com.android.tools.build:gradle:0.8.+' 改为 1classpath 'com.android.tools.build:gradle:2.2.3'（目前最高版本） gradle/wrapper/gradle-wrapper.properties。 找到 1distributionUrl=http\\://services.gradle.org/distributions/gradle-1.10-all.zip 改为 1distributionUrl=http\\://services.gradle.org/distributions/gradle-2.14.1-all.zip（目前最高版本） 三.导入 Android Studio在 Android Studio 的 Welcome 界面选择 import project（Eclipse ADT,Gradle,etc） 选择工程，等待编译完成。这时候，不会马上编译成功，需要耐心，根据编译错误信息修改错误。常见的错误有： jni 库位置、构建工具版本低、图片检查报错、Manifest 冲突、jar 包冲突等。 四.常见编译错误解决方法 jni 库位置。在 build.gradle 中添加： 12345sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125;&#125; 构建工具版本低。提高构建工具版本，一般 Android Studio 都会有提示。 图片检查报错。把 .9 图片放到 dawable 文件夹而不是 mipmap 文件夹；在 build.gradle 中添加： 1234aaptOptions &#123; cruncherEnabled false useNewCruncher false&#125; Manifest 冲突。删除重复的 uses-permission 权限；忽略 Manifest 资源值冲突： 在 manifest 根标签上加入: 1xmlns:tools=\"http://schemas.android.com/tools\" 然后，在 application 标签下添加: 1tools:replace=\"android:icon, android:theme\"（多个属性用,隔开） 或者直接在 gradle 中添加： 1useOldManifestMerger true jar 包冲突。删除 library 工程中与主工程冲突的 jar 包。 五.库工程（Library）打 aar 包如果工程中有依赖工程（即 Library 工程，Android Studio 中称 Module 工程），那么最好将它打成 aar 包，以提高日常调试时的编译速度。因为 Android Studio 每次编译的时候，都会把项目下的所有工程都编译一遍，这样会浪费一些不必要的时间。所以，如果不是特殊情况，最好将 Module 工程打成 aar 包来使用。那这个 aar 怎么生成呢？ 首先，当我们做完前面的操作，程序都正常跑起来了之后。 在 Module 工程的 \\build\\outputs\\aar\\ 下可以找到编译生成的 aar 包，把 aar 包拷到主工程的 \\libs\\ 下。 去掉根目录下 settings.gradle 文件中原来工程的 include ： 1// include ':XXXXX' 将主工程中 build.gradle 文件的工程依赖关系，改为 aar 包依赖： 12// compile project(':XXXXX')compile(name: 'XXXXX', ext: 'aar') 点击右上角 Sync Now，等待 gradle 完成，这样就 OK 了，是不是很简单！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"PopupWindow用法及源码浅析","slug":"Android_PopupWindow","date":"2017-02-22T11:40:00.000Z","updated":"2018-05-25T05:55:53.735Z","comments":true,"path":"2017/02/22/Android_PopupWindow/","link":"","permalink":"http://laocaixw.github.io/2017/02/22/Android_PopupWindow/","excerpt":"","text":"最近手头上的事比较多，博客也荒废了有三四个月，趁这几天任务稍微轻一点，也正好把这段时间学到的东西做个总结，对自己来说也是一种进步。 作为 Android 开发者一定对 AlertDialog 对话框很熟悉，与它类似的 PopupWindow 对于初学者来说可能接触得就比较少，但是 PopupWindow 也是常用的对话框控件之一。 1.用法PopupWindow 的基本用法（ PopupWindow 的用法网上也有很多，想了解更多可以上网搜，这里只是写了个简单的）： 1234// 实例化，顾名思义，contentView 就是要显示的内容，width 和 height 就是宽和高PopupWindow popupWindow = new PopupWindow (contentView, width, height);// 显示 PopupWindow，相对于父控件的位置popupWindow.showAtLocation(parent, gravity, x, y); 2.监听返回键大部分人可能需要让 PopupWindow 响应返回键，当 PopupWindow 显示的时候，按下返回键需要把 PopupWindow 关闭掉。 如果没有给 PopupWindow 设置焦点（即setFocusable(false);），那么我们就要在 Activity 的 onBackPressed 方法中关闭 PopupWindow。如果给 PopupWindow 设置了焦点（即 setFocusable(true);），这时候想要响应返回键，网上流传了一种方法，就是给 PopupWindow 设置背景。 为什么会这样呢？我们来看一下源码（这里是 Android-19 的源码），我们顺着 showAtLocation() 方法点进去，会看到 preparePopup() 方法，里面有这样一段代码： 12345678910111213141516171819if (mBackground != null) &#123; final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); int height = ViewGroup.LayoutParams.MATCH_PARENT; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; height = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; PopupViewContainer popupViewContainer = new PopupViewContainer(mContext); PopupViewContainer.LayoutParams listParams = new PopupViewContainer.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, height ); popupViewContainer.setBackgroundDrawable(mBackground); popupViewContainer.addView(mContentView, listParams); mPopupView = popupViewContainer;&#125; else &#123; mPopupView = mContentView;&#125; 当给 PopupWindow 设置背景时，它会给 contentView 外面套上一个 PopupViewContainer ，这个 PopupViewContainer 是 PopupWindow 的一个内部类，它已经把返回键事件给消费掉了，并且还 dismiss 了 PopupWindow ，所以网上流传的这段代码说起来也是可行的。 3. Android 6.0 之后的坑公司的项目里有一个加载框，就是用 PopupWindow 来实现的，但是公司做出来的效果是，当在请求网络数据时，显示这个加载框，并且不让用户做任何操作，只有请求结束后，才通过代码关闭这个加载框。那么可能有人就想到，不给它设焦点，然后在 Activity 的 onBackPressed 方法中拦截返回事件。但是，由于公司项目框架比较特殊，Activity 的返回键涉及方面较多，不能随意拦截，所以没办法用这种办法。那么可能有人又想到另一个办法，给它设焦点，然后不给它设置背景（我们项目就是这么做的）。但是在 6.0 中，按返回键是可以把 PopupWindow 给关掉的。这又是怎么回事呢？我们继续来看源码(这里是 Android-23)。 12345678if (mBackground != null) &#123; mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground);&#125; else &#123; mBackgroundView = mContentView;&#125;mDecorView = createDecorView(mBackgroundView); 可以看到，无论是否设置了背景，最终都要 createDecorView ，这个 createDecorView 又是干什么的呢？继续往下看。 12345678910111213141516private PopupDecorView createDecorView(View contentView) &#123; final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; height = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; else &#123; height = ViewGroup.LayoutParams.MATCH_PARENT; &#125; final PopupDecorView decorView = new PopupDecorView(mContext); decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height); decorView.setClipChildren(false); decorView.setClipToPadding(false); return decorView;&#125; 我们可以看到无论是否设置了背景，这边都会在外面套上一层 PopupDecorView ，而这个万恶的 PopupDecorView 竟然几乎就是 6.0 之前的那个 PopupViewContainer ，把 PopupWindow 关闭了还把我的返回键事件给消费掉了！ 4.结局万般无奈之下，只好将 PopupWindow 改为 AlertDialog 了！虽然改动了之后，影响的地方比较多，需要测试的也比较多，但是，加载框和 AlertDialog 还是更合适哦！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Git中.gitignore文件的规则","slug":"Git_gitignore","date":"2016-11-10T03:00:00.000Z","updated":"2017-11-18T02:19:03.409Z","comments":true,"path":"2016/11/10/Git_gitignore/","link":"","permalink":"http://laocaixw.github.io/2016/11/10/Git_gitignore/","excerpt":"","text":"在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中.gitignore文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如： 1234567# 此为注释 – 将被 Git 忽略 *.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos;","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://laocaixw.github.io/tags/Git/"}]},{"title":"设计模式学习系列（1）--单例模式","slug":"Design_Mode_1_Singleton","date":"2016-11-07T14:13:03.000Z","updated":"2018-06-10T03:50:25.616Z","comments":true,"path":"2016/11/07/Design_Mode_1_Singleton/","link":"","permalink":"http://laocaixw.github.io/2016/11/07/Design_Mode_1_Singleton/","excerpt":"","text":"单例模式：确保一个类只有一个实例存在，而且自行实例化并向整个系统提供这个实例。单例模式可以用在建立目录、数据库连接等需要单线程操作的场合，用于实现对系统资源的控制。 单例模式通常有两种：1.饿汉式：类加载时，就进行对象实例化。2.懒汉式：第一次引用类时，才进行对象实例化。 1. 饿汉式123456789101112public class Singleton &#123; private static Singleton mInstance = new Singleton(); // 构造方法私有化，保证外界无法直接实例化 private Singleton() &#123; &#125; // 通过该方法获得实例对象 public static Singleton getInstance() &#123; return mInstance; &#125;&#125; 2. 懒汉式1234567891011121314public class Singleton &#123; private static Singleton mInstance = null; private Singleton() &#123; &#125; // 方法同步，确保多线程环境下只创建一个实例 synchronized public static Singleton getInstance() &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; return mInstance; &#125;&#125; 在多线程开发中，往往需要使用 synchronized 关键字对代码进行同步，否则，可能在内存中生成多个实例，这样就违反了单例模式，严重的会影响程序正常运行。 由于 Java 中， synchronized 同步代码块是会抢占线程资源的，这导致了其他线程都会堵在这个方法上，这一定程度上影响了程序的效率。所以就有了以下这种双重非空判断的方法： 123456789101112131415161718public class Singleton &#123; private static Singleton mInstance = null; private Singleton() &#123; &#125; // 双重非空判断，以保证程序运行的效率 public static Singleton getInstance() &#123; if (mInstance == null) &#123; synchronized (Singleton.class) &#123; if (mInstance == null) &#123; mInstance = new Singleton(); &#125; &#125; &#125; return mInstance; &#125;&#125; 显然，饿汉式响应速度更快，而懒汉式更省资源。而实际上，饿汉式更符合 Java 语言本身特点。 源码地址https://github.com/laocaixw/DesignModeLearning","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Appium测试Android混合应用的坑","slug":"Android_Appium_Mixed_App","date":"2016-11-01T12:32:34.000Z","updated":"2018-04-04T08:25:07.261Z","comments":true,"path":"2016/11/01/Android_Appium_Mixed_App/","link":"","permalink":"http://laocaixw.github.io/2016/11/01/Android_Appium_Mixed_App/","excerpt":"","text":"Appium测试Android混合应用时,第二次切换到WebView时的定位问题在用 Appium 测试 Android 混合应用时，当程序第一次切换到 WebView 时，可以正常进行自动化测试。可是当程序第二次切换到 WebView 时，Appium 会自动找到到第一次打开的 Html 页面，那么这时 Appium 就无法定位我们第二次打开的 Html 页面中的元素。 最近在做 Android 自动化测试开发，遇到了一个对我这种初学者来说非常棘手的难题，网上怎么找也找不到解决方案，不过最终还是被自己瞎猫碰到了死耗子~~在这里做个记录。废话就不多说，这里就直接提供我的解决方案。 解决方案:修改 Appium 源码Appium 安装目录下的文件 Appium\\node_modules\\appium\\lib\\devices\\android\\android-hybrid.js，文件中有这样一个函数： 123456789101112131415androidHybrid.startChromedriverProxy = function (context, cb) &#123; cb = _.once(cb); logger.debug(\"Connecting to chrome-backed webview\"); if (this.chromedriver !== null) &#123; return cb(new Error(\"We already have a chromedriver instance running\")); &#125; if (this.sessionChromedrivers[context]) &#123; // in the case where we've already set up a chromedriver for a context, // we want to reconnect to it, not create a whole new one this.setupExistingChromedriver(context, cb); &#125; else &#123; this.setupNewChromedriver(context, cb); &#125;&#125;; 改为： 12345678910111213141516androidHybrid.startChromedriverProxy = function (context, cb) &#123; cb = _.once(cb); logger.debug(\"Connecting to chrome-backed webview\"); if (this.chromedriver !== null) &#123; return cb(new Error(\"We already have a chromedriver instance running\")); &#125; // if (this.sessionChromedrivers[context]) &#123; // // in the case where we've already set up a chromedriver for a context, // // we want to reconnect to it, not create a whole new one // this.setupExistingChromedriver(context, cb); // &#125; else &#123; // this.setupNewChromedriver(context, cb); // &#125; this.setupNewChromedriver(context, cb);&#125;; Appium 第一次切换到 Html 页面时，会新生成一个 Chromedriver ；当第二次切换到 Html 时，会使用已经存在的 Chromedriver 。但其实在我们的应用里面每次打开一个 Activity 时一般都是会重新创建一个 WebChromeClient ，所以这里就把它改成无论如何都生成一个新的 Chromedriver 。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"Appium","slug":"Appium","permalink":"http://laocaixw.github.io/tags/Appium/"}]},{"title":"设计模式学习系列（0）--概述及设计原则","slug":"Design_Mode_0_Summary","date":"2016-10-31T14:30:27.000Z","updated":"2017-11-16T07:00:56.853Z","comments":true,"path":"2016/10/31/Design_Mode_0_Summary/","link":"","permalink":"http://laocaixw.github.io/2016/10/31/Design_Mode_0_Summary/","excerpt":"","text":"先说概念：设计模式是一套被反复使用、多数人知晓、经过分类编目的优秀代码设计经验的总结。 Java 设计模式贯彻的原理是：面向接口编程，而不是面向现实。其目标原则是：降低耦合，增强灵活性。 通俗点来讲： 面向接口。举个例子，作为程序员，我们平时接触最多的就是电脑了，大部分人应该都有换过或加过内存条、硬盘等经验，为什么这些东西可以这么轻易更换呢？因为这些东西都是针对接口设计的。程序设计其实也是一样，如果那部分程序需要移植或出了问题，那么只要简单知道接口，就很容易办到了。 降低耦合。就是让模块之间的关系更少，当然也就是更容易接起来咯。把程序模块化，这样就易移植、易修改。 常用的设计模式总共有 23 种，可分为： 创建型：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式； 结构型：代理模式、装饰模式、适配器模式、组合模式、桥梁模式、外观模式、亨元模式； 行为型：模板方法模式、命令模式、责任链模式、策略模式、迭代器模式、中介模式、观察者模式、备忘录模式、访问者模式、状态模式、解释器模式。 设计原则下面说下程序设计的几个原则。 1.单一职责原则一个类应当只有一个引起它变化的原因，即一个类应该只有一个职责。 这个应该很好理解，就是为了降低耦合，让类与类之间不要有太多的牵制，看起来更简单，也可以让代码有更好的可读性，当然也就会更容易维护和扩展。 单一职责原则的优点可以概括为： 降低类的复杂性； 提高代码的可读性； 提高代码的可维护性和可复用性； 降低因变更引起的风险。 2.里式替换原则任何基类可以出现的地方，子类一定可以出现。 意思就是子类必须可以替换掉它们的父类，主要是为了让子类可以出现的地方尽量用它们的父类来代替，可以使程序更容易维护。让子类可以出现的地方，以它的父类来代替，这样当我们需要改变这个子类的时候，只需要在它的父类下再新增一个类而不是去修改这个子类，从而可以省去很多改动。 里式替换原则为良好的继承定义了一个规范： 子类必须完全实现父类的方法； 子类可以有自己的个性； 覆盖或实现父类的方法时输入参数可以被放大； 覆盖或实现父类的方法时输出结果可以被缩小。 按照里式替换原则，当多个类之间存在继承关系时，通常应该使用父类或接口来指向子类的对象（除非需要使用子类特有的方法），这更利于提高系统的可扩展性。 3.依赖倒置原则高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。 (这里的抽象可以是抽象类或者接口) 依赖关系：A 依赖 B 的意思是，如果 A 要完成某一操作，必须使用B的某些操作来帮忙，才能完成。简言之，B 作为 A 的某个方法的方法参数存在。例如，汽车(B)能跑，司机(A)必须有汽车(B)开，才能算是司机，否则他只是个普通的人，所以司机(A)依赖汽车(B)。 在项目中使用这个原则只要遵循以下几个规则： 每个类尽量都具有接口或者抽象类，或者两者都有，这是依赖倒置的基本要求； 变量的表面类型尽量是接口或者抽象类； 任何类都不应该从具体类派生； 尽量不要重写基类的方法； 结合里式替换原则使用：接口负责定义抽象方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。 这其实就可以算是“面向接口编程”，这里有一个例子可以参考，以便于更好理解。 4.接口隔离原则客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 接口隔离原则跟单一职责原则有点像，一个是针对接口，一个是针对类，其实它们的思想是差不多的。我们在设计程序的时候，应该尽量去建立多个单一模块的接口，不要去建立一个臃肿庞大的接口。接口要尽量的细化，同时接口中的方法要尽量少。 其实无论是那个设计原则，都是为了让我们的程序更容易维护，更容易扩展。接口隔离也是一样，当要程序要引进新的功能时，不会对太多功能造成影响。 接口隔离原则需要注意的： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 5.迪米特法则迪米特法则又叫最少知识原则，意思是一个对象应当对其他对象尽可能少的了解。 只与你直接的朋友们通信，不要跟陌生人说话。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 举个简单的例子：如果 A 和 B 之间存在关联，B 和 C 之间存在关联，A 和 C 之间不存在关联。那么如果 A 想要调用 C 的方法，最好让 A 通过 B 去调用 C 的方法，而不是让 A 和 C 关联起来。 迪米特法则的好处就是，减少类之间的关联，降低类之间的耦合，使类的复用率更高。 迪米特法则还有一层意思，就是一个类应该尽量少的开发他们方法，能用 protected 和 private 的地方尽量不要用 public 。 6.开闭原则对扩展开放，对修改关闭。 开闭原则的重要性可以通过以下几方面来体现： 开闭原则提高可复用性。 开闭原则提高可维护性。 开闭原则提高灵活性。 开闭原则易于测试。 总的来说，无论什么设计原则，都是为了让程序更容易维护，更容易扩展。只要我们在设计程序的时候多想想是不是更容易维护，更容易扩展，是不是符合这些设计原则，我们就可以写出更好更健壮的代码。 UML类图学设计模式之前，可以先学一下 UML 类图，以便更好理解某些内容。这里有个很容易理解的例子。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://laocaixw.github.io/tags/设计模式/"}]},{"title":"Android中NFC读取金融IC卡","slug":"Android_NFC_Read_ICCard","date":"2016-09-21T13:15:10.000Z","updated":"2018-04-04T08:15:45.837Z","comments":true,"path":"2016/09/21/Android_NFC_Read_ICCard/","link":"","permalink":"http://laocaixw.github.io/2016/09/21/Android_NFC_Read_ICCard/","excerpt":"","text":"这篇文章具体分为以下几部分： Android 中 NFC 的基本使用方法； NFC 读取金融 IC 卡步骤； 读卡过程中涉及到的报文格式解析。 一、Android 中 NFC 的基本使用方法NFC手机相比普通手机来说，有以下3个附加功能： 可以当成 POS 机来用，也就是“读取”模式 可以当成一张卡来刷，也就是 NFC 技术最核心的移动支付功能 可以像蓝牙、 Wi-Fi 一样做点对点通信 这里要说的就是第一种，”读卡” ! 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class NFCActivity extends Activity &#123; private NfcAdapter mNfcAdapter = null; private PendingIntent mPendingIntent = null; private IntentFilter[] mIntentFilter = null; private String[][] mTechList = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.acitivity_nfc); nfcCheck(); mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0); // 过滤器总共有三种 IntentFilter intentFilter1 = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED); IntentFilter intentFilter2 = new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED); IntentFilter intentFilter3 = new IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED); mIntentFilter = new IntentFilter[]&#123;intentFilter1, intentFilter2, intentFilter3&#125;; // 只针对ACTION_TECH_DISCOVERED mTechList = new String[][]&#123; &#123;IsoDep.class.getName()&#125;, &#123;NfcA.class.getName()&#125;, &#123;NfcB.class.getName()&#125;, &#123;NfcV.class.getName()&#125;, &#123;NfcF.class.getName()&#125;, &#123;Ndef.class.getName()&#125;&#125;; &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); Log.i(\"MyLog\", \"Tag:\" + intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)); IsoDep isoDep = IsoDep.get((Tag) intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)); try &#123; isoDep.connect(); byte[] payload = stringToBytes(\"00A404000E315041592E5359532E4444463031\"); // 将字符串转为byte数组 byte[] data = isoDep.transceive(payload); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, mIntentFilter, mTechList); &#125; @Override protected void onPause() &#123; super.onPause(); mNfcAdapter.disableForegroundDispatch(this); &#125; private void nfcCheck() &#123; mNfcAdapter = NfcAdapter.getDefaultAdapter(this); if (mNfcAdapter == null) &#123; Toast.makeText(this, \"本机不支持NFC\", Toast.LENGTH_SHORT).show(); finish(); return; &#125; else &#123; if (!mNfcAdapter.isEnabled()) &#123; // NFC未打开 Intent setNfc = new Intent(Settings.ACTION_NFC_SETTINGS); startActivity(setNfc); &#125; &#125; &#125; public byte[] stringToBytes(String s) &#123; int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) &#123; data[(i / 2)] = ((byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character .digit(s.charAt(i + 1), 16))); &#125; return data; &#125; public String bytesToString(byte[] data) &#123; String temp = \"\"; for (byte d : data) &#123; temp += String.format(\"%02X\", d); &#125; return temp; &#125; &#125; 这里在 nfcCheck() 方法中检查手机是否支持 NFC 功能和 NFC 是否开启， NfcAdapter 就是手机的 NFC 适配器。 12mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, mIntentFilter, mTechList);mNfcAdapter.disableForegroundDispatch(this); 在 onResume() 和 onPause() 方法中，这两个方法分别表示前台读取 Tag （就是指卡片）的开关。一旦手机检测到卡片， onNewIntent(Intent intent) 方法就会执行。 IsoDep 可以看做一个与卡片通信的工具类。 intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) 就是表示 Tag （卡片）； isoDep.connect() 就是手机 NFC 与卡片连接； isoDep.transceive(payload) 就是向卡片发送报文，它的返回数据就是卡片的响应报文，这里都是通过 byte 数组通信的。 二、 NFC 读取金融 IC 卡步骤具体的读卡步骤可以参考《中国金融集成电路（IC）卡规范》、《中国银联IC卡技术规范》等，这边简化如下，有兴趣的可以自己往上加： 应用选择； 应用初始化； 读应用数据； 生成应用密文。 1.应用选择 说明: 这里图片内容大多来自《中国金融集成电路（IC）卡规范》，建议参考。 终端接收到卡片发来的数据大多数都是 TLV 格式的数据， TLV 格式数据详解见本文第三部分，建议先理解 TLV 格式后再继续往下看。 下文命令都以 16 进制表示。 9000为响应成功状态码。 (1) 使用 SELECT 命令选择文件: 1PAY.SYS.DDF01 即命令为： 00-A4-04-00-0E-315041592E5359532E4444463031 发送： 00A404000E315041592E5359532E4444463031 接收： 6F1E840E315041592E5359532E4444463031A50C8801015F2D027A689F1101019000 从接收到的数据中，按 TLV 格式解析，可以得到 SFI(88) 为 01 ，下一步需要用到。 (2) 根据 SFI 发送读记录 READ RECORD 命令 SFI 为 01 ，即 0000 0001 ，低三位为 100 ，所以引用控制参数 P2 为 00001 100 ，即 0C 。所以读记录命令为： 00-B2-01-0C-00 发送： 00B2010C00 接收： 702861264F08A000000333010101500A50424F432044454249548701019F120A50424F432044454249549000 同样，按 TLV 格式解析，得到应用标识符 AID(4F) 为 A000000333010101 (3) 根据 AID 选择应用发送： 00A4040008A000000333010101 接收： 6F548408A000000333010101A548500A50424F432044454249548701019F38189F66049F02069F03069F1A0295055F2A029A039C019F37045F2D027A689F1101019F120A50424F43204445424954BF0C059F4D020B0A9000 按 TLV 格式解析，得到 PDOL 的数据 (9F38) 为 9F66049F02069F03069F1A0295055F2A029A039C019F3704 。这里的 PDOL 数据不是 TLV ，只有命令部分类似 TLV ， PDOL 数据为多条“命令+长度”组合而成。分解如下： 命令:长度 名称 9F66:04 终端交易属性 9F02:06 授权金额,消费金额 9F03:06 其它金额，目前还没有定义 9F1A:02 终端国家代码,中国：0156 95:05 终端验证结果 5F2A:02 交易货币代码 9A:03 交易日期 9C:01 交易类型 9F37:04 不可预知数,最好去随机数 2.应用初始化(1) 获取处理选项 根据上一步得到的 PDOL 数据，按照顺序发送 GET PROCESSING OPTIONS 命令。 80-A8-00-00-23-83-21-40800000-000000000000-000000000000-0156-0000000000-0156-160913-99-4D23571A 。 83 表示 GPO 数据。 发送： 80A8000023832140800000000000000000000000000000015600000000000156160913994D23571A 接收： 80127C00080101001001030118010300200101009000 响应分解： 80-12-7C00-08010100-10010301-18010300-20010100-9000 7C00 为 AIP ，后面每4个字节为一个 AFL 。 以 10010301 为例： 10 即 0001 0000 ，前五位为 SFI； 01 表示第一条要读的记录； 03 表示最后一条要读的记录； 01 表示从第一个记录开始的用于脱机数据认证的连续记录数 3.读应用数据根据上一步返回的 AFL 逐条读取应用数据，即逐条发送读记录命令：00B2010C00；00B2011400，00B2021400，00B2031400；00B2011C00，00B2021C00，00B2031C00；00B2012400。返回的数据都是 TLV 格式的报文，把每次读记录得到的响应解析出来，应用数据包括卡号什么的都在里面了。在返回的数据中包括了一个 CDOL1(8C) 数据: 9F02069F03069F1A0295055F2A029A039C019F37049F21039F4E14 ，这个跟前文中的 PDOL 数据类似。 命令 长度 9F02 06 9F03 06 9F1A 02 95 05 5F2A 02 9A 03 9C 01 9F37 04 9F21 03 9F4E 14 4.生成应用密文根据上一步得到的 CDOL1 ，发送 GENERATE AC 命令，来生成应用密文。 这里要生成一个 ARQC 密文，80-AE-80-00-34-000000000000000000000000015600000000000156160913994D23571A000000000000000000000000000000000000000000000000 发送：80AE800034000000000000000000000000015600000000000156160913994D23571A000000000000000000000000000000000000000000000000 接收：801E8000750317DB9AEDE4DD5607010103A0A000010A010000000000890C15B29000 按 TLV 格式解析，得到一个 80 数据：8000750317DB9AEDE4DD5607010103A0A000010A010000000000890C15B2 分解如下：80-0075-0317DB9AEDE4DD56-07010103A0A000010A010000000000890C15B2 应用交易计数器: 0075 应用密文: 0317DB9AEDE4DD56 发卡行应用数据: 07010103A0A000010A010000000000890C15B2 三、读卡过程中涉及到的报文格式解析1.TLV 格式解析TLV 就是 Tag + Length + Value 。Tag 是标识，Length 是后面数据值 Value 的长度。 TLV 数据可以有复合数据，即一个 TLV 中的 Value 还可以包含一个或多个 TLV 。 (1) TagTag 最多可以占两个字节，编码规则如下： 第一图表示第一个字节的编码规则，b6 决定当前的 TLV 数据是单一结构的数据或者复合结构的数据。 b5-b1 如果全为1，则这个 Tag 占两个字节，否则只占一个字节。 如果 Tag 占两个字节，则第二图表示第二个字节的编码规则。 b8 决定 Tag 是否还有后绪的字节存在，因为 PBOC/EMV 里的 Tag 最多占两个字节, 所以该位保持为 0。 所以： 123456789101112if ((tlvData[i] &amp; 0x20) != 0x20) &#123; // 单一结构 if ((tlvData[i] &amp; 0x1F) == 0x1F) &#123; // tag两字节 tagIndex++; // 解析length域 // 解析value域 &#125; else &#123; // tag单字节 // 解析length域 // 解析value域 &#125;&#125; else &#123; // 复合结构 // 复合结构可以考虑用递归的方法来实现.&#125; (2) LengthLength 最多可以有四个字节。如果第一个字节的最高位 b8 为 0，b7-b1 的值就是 value 域的长度；如果 b8 为 1，b7-b1 的值就表示了下面有几个子字节，下面子字节的值就是 value 域的长度。 (3) ValueValue 的编码格式要根据具体 Value 所表示的数据元决定，有可能还是 TLV 格式的数据，也有可能是其他数据。 引用最后，感谢以下博客的博主： http://blog.csdn.net/lvxiangan/article/details/17218409 http://blog.csdn.net/kxd_ysheng/article/details/21178101 http://blog.csdn.net/kxd_ysheng/article/details/21237957 http://blog.csdn.net/artmcu/article/details/8086153 http://blog.chinaunix.net/uid-20551291-id-3340818.html http://blog.sina.com.cn/s/blog_625033800101f5cm.html http://blog.sina.com.cn/s/blog_a20257d80101n17j.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Volley的用法","slug":"Android_Volley","date":"2016-07-28T04:47:01.000Z","updated":"2017-11-16T06:53:11.845Z","comments":true,"path":"2016/07/28/Android_Volley/","link":"","permalink":"http://laocaixw.github.io/2016/07/28/Android_Volley/","excerpt":"","text":"Volley 是谷歌官方推出的一个Android网络通信框架库，既可以做普通的网络请求，又可以做图片的异步加载和缓存处理，适用于通信频繁的网络操作。如果是加载的图片较多，不建议用Volley的本地缓存，因为经本人测试，如果缓存图片较多，Volley加载本地缓存的速度非常慢。参考：郭霖的博客。 1.下载Volley1git clone https://android.googlesource.com/platform/frameworks/volley 2.Volley的用法 1.获取一个请求队列； 2.创建一个请求对象； 3.将请求对象加到请求队列中。 Volley 的请求对象有： StringRequest 、 JsonRequest 、 ImageRequest ，对于图片还有 ImageLoader 、 NetworkImageView ，另外还可以定制自己的 Request 。 简单的 StringRequest 请求对象用法：1234567891011121314RequestQueue mQueue = Volley.newRequestQueue(context);StringRequest stringRequest = new StringRequest(url, new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; Log.d(\"TAG\", response); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;);mQueue.add(stringRequest); 简单的 JsonRequest 请求对象用法：1234567891011121314RequestQueue mQueue = Volley.newRequestQueue(context);JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(rul, null, new Response.Listener&lt;JSONObject&gt;() &#123; @Override public void onResponse(JSONObject response) &#123; Log.d(\"TAG\", response.toString()); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;);mQueue.add(jsonObjectRequest); 简单的 ImageRequest 请求对象用法：1234567891011121314RequestQueue mQueue = Volley.newRequestQueue(context);ImageRequest imageRequest = new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap response) &#123; imageView.setImageBitmap(response); &#125; &#125;, 0, 0, Config.RGB_565, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; imageView.setImageResource(R.drawable.default_image); &#125; &#125;);mQueue.add(imageRequest); ImageLoader 的用法12345678910111213141516RequestQueue mQueue = Volley.newRequestQueue(context);ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() &#123; //本地缓存 @Override public void putBitmap(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap getBitmap(String url) &#123; return null; &#125;&#125;);ImageListener listener = ImageLoader.getImageListener(imageView, R.drawable.default_image, R.drawable.failed_image);imageLoader.get(imageUrl, listener);//imageLoader.get(imageUrl, listener, 200, 200); // 指定图片允许的最大宽度和高度 这里可以根据个人需要加入LruCache做个内存缓存。 NetworkImageView 的用法NetworkImageView 是一个继承自 ImageView 的控件， ImageView 有的属性它基本都有。 在布局中添加控件： 123456&lt;com.android.volley.toolbox.NetworkImageView android:id=\"@+id/network_image_view\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:layout_gravity=\"center_horizontal\" /&gt; 用法： 1234567891011121314151617networkImageView = (NetworkImageView) findViewById(R.id.network_image_view);networkImageView.setDefaultImageResId(R.drawable.default_image);networkImageView.setErrorImageResId(R.drawable.failed_image);RequestQueue mQueue = Volley.newRequestQueue(context);ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() &#123; //本地缓存 @Override public void putBitmap(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap getBitmap(String url) &#123; return null; &#125;&#125;);networkImageView.setImageUrl(imageUrl, imageLoader); 自定义 Request可以参考 StringRequest 源码，自定义 XMLRequest： 1234567891011121314151617181920212223242526272829303132public class XMLRequest extends Request&lt;XmlPullParser&gt; &#123; private final Listener&lt;XmlPullParser&gt; mListener; public XMLRequest(int method, String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123; // 带请求方式的构造函数 super(method, url, errorListener); mListener = listener; &#125; public XMLRequest(String url, Listener&lt;XmlPullParser&gt; listener, ErrorListener errorListener) &#123; // 不带请求方式的构造函数 this(Method.GET, url, listener, errorListener); &#125; @Override protected Response&lt;XmlPullParser&gt; parseNetworkResponse(NetworkResponse response) &#123; // 获取响应后通过此函数得到一个XmlPullParser的响应 try &#123; String xmlString = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlString)); return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (XmlPullParserException e) &#123; return Response.error(new ParseError(e)); &#125; &#125; @Override protected void deliverResponse(XmlPullParser response) &#123; mListener.onResponse(response); &#125;&#125; 使用自定义的 XMLRequest： 123456789101112131415RequestQueue mQueue = Volley.newRequestQueue(context);XMLRequest xmlRequest = new XMLRequest(url, new Response.Listener&lt;XmlPullParser&gt;() &#123; @Override public void onResponse(XmlPullParser response) &#123; // 在此对得到的XmlPullParser响应做处理 &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;); mQueue.add(xmlRequest); 3.Volley 源码分析官方图解： 估计也就只有我能看懂的图解分析： 总的来说，volley 是开了一个缓存线程和四个网络线程，当一个请求被加到队列中后，会先查看是否有缓存，如果有缓存那么走缓存线程读取缓存数据，如果没有则将请求加入到网络线程队列，读取网络数据。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://laocaixw.github.io/tags/Volley/"}]},{"title":"Android Studio上的NDK开发","slug":"Android_Studio_NDK","date":"2016-07-25T16:22:41.000Z","updated":"2018-04-04T07:39:55.622Z","comments":true,"path":"2016/07/26/Android_Studio_NDK/","link":"","permalink":"http://laocaixw.github.io/2016/07/26/Android_Studio_NDK/","excerpt":"","text":"Android 的 NDK 开发，也可以称为 Android 的 JNI 开发。 NDK 是一系列工具， JNI 是一种技术或者说是一种协议。 刚刚学了 Android 的 NDK 开发，但是教程是基于 Eclipse 的，为了赶上节奏，马不停蹄的在 Android Studio 上做实验，鼓捣了半天，也踩了不少坑，就这里做个记录！ 首先是自己的各种版本，基本都是目前最新的：Android Studio 2.1.2，NDK 12.1，gradle 2.1.2。 万万没想到，这是我踩最大的坑：文件夹名中有空格！ 1.给项目 gradle.properties 加上以下代码，表示要用 NDK 了： 1android.useDeprecatedNdk=true 2.在 local.properties 中加入 ndk 和 sdk 的路径： 12ndk.dir=D\\:\\\\work\\\\Android\\\\sdk\\\\ndk-bundlesdk.dir=D\\:\\\\work\\\\Android\\\\sdk 3.在 app 文件夹下的 build.gradle 中的 defaultConfig 里加入： 1234ndk&#123; moduleName \"NDKTest\" abiFilters \"armeabi\",\"x86\" &#125; 其中 moduleName 指要生成的 .so 文件名称，这个要记住，后面还会用到。 abiFilters 指要生成哪几个平台的 so 文件。 4.新建一个 Java 类，要通过这个类来调用 C/C++ 的代码： 123456public class GetString &#123; static &#123; System.loadLibrary(\"NDKTest\");//导入生成的链接库文件 &#125; public static native String getStr();&#125; 其中用 native 修饰的方法，就是要在 C/C++ 中实现的方法， System.loadLibrary(&quot;NDKTest&quot;) 是表示要调用 NDKTest 这个 so 文件，就是3中的 moduleName 。 5.在 \\app\\src\\main\\ 中新建 jni 目录（右键-&gt;new-&gt;Folder-&gt;JNI Folder）。然后编译（Build-&gt;Make Project）生成 .class 文件，这里主要是要得到 GetString.class 这个类。生成的 class 文件在工程的 \\app\\build\\intermediates\\classes\\debug\\ 里。用 Terminal 命令行工具 cd 进入此文件夹，输入以下命令生成头文件： 1javah -d ../../../../src/main/jni/ -jni com.laocaixw.ndktest.GetString 这里说明一下： javah ——是要将 java 类输出为 C/C++ 的 .h 头文件。 -d ../../../../src/main/jni/ ——这段表示文件输出的位置，这里 ../ 表示返回上层目录，这样写是什么意思应该就能理解了，表示输出到 \\app\\src\\main\\jni\\ 里。 -jni com.laocaixw.ndktest.GetString ——这里 -jni 就是 jni 的命令咯， com.laocaixw.ndktest.GetString 就是指当前目录下的 com.laocaixw.ndktest.GetString 这个类。 6.执行完以上命令后，会在 \\app\\src\\main\\jni\\ 下生成 com_laocaixw_ndktest_GetString.h 文件，里面应该有一个类似这样的函数： 12JNIEXPORT jstring JNICALL Java_com_laocaixw_ndk_GetString_getStr (JNIEnv *, jclass); 7.在 \\app\\src\\main\\jni\\ 里新建一个 C/C++ 文件 .cpp ，将6中的头文件引入，并把上述函数复制进来，做以下修改： 123456#include \"com_laocaixw_ndktest_GetString.h\"JNIEXPORT jstring JNICALL Java_com_laocaixw_ndk_GetString_getStr (JNIEnv *env, jclass) &#123; return env-&gt;NewStringUTF(\"Hello NDK\"); &#125; 这里表示，当 java 中调用 GetString.getStr() 时，会调用 C/C++ 中的上述这个函数，然后返回 “Hello NDK” 。 8.最后 Make Project 一下，看是不是在 \\app\\build\\intermediates\\ndk\\debug\\ 下生成了 so 文件，如果是，那么应该大功告成，可以运行了。 9.最后，编译运行前，别忘了把打开了 \\app\\build\\intermediates\\classes\\debug\\ 的 Terminal 命令行工具关掉，否则占用这个文件夹会导致编译不成功。因为编译的时候，会把build里的东西全部删除再重新生成，如果占用的话，删除不了就会出错。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://laocaixw.github.io/tags/Android/"}]},{"title":"Git的科学上网方式","slug":"Git_Science_Internet","date":"2016-07-03T08:18:28.000Z","updated":"2017-11-16T13:31:49.830Z","comments":true,"path":"2016/07/03/Git_Science_Internet/","link":"","permalink":"http://laocaixw.github.io/2016/07/03/Git_Science_Internet/","excerpt":"","text":"最近从 CSDN 博客上学习了 Android 的网络开源库 Volley 的一些基本用法（郭大神的博客），volley 是谷歌推出的，想要下载它的话当然得用科学的上网方式了。虽然从网上也可以下载到已经打包好的volley.jar，但是还是想自己从官网克隆下来，因为谁知道网上下载的纯不纯呢。 于是，从网上各种搜索，再自己各种测试，终于功夫不负有心人！于是把方法记录下来。 因为我平时科学上网没有买代理，用的是一个免费的软件赛风，一键上网，虽然速度慢，而且不稳定，但是可以用。如果你也是用的赛风，那你就可以看看我的教程。 首先你要了解 git 设置代理服务器和恢复默认的方法： 1.设置代理服务器： 1git config --global http.proxy http://proxyuser:proxypwd@proxy.server.com:8080 1git config --global https.proxy https://proxyuser:proxypwd@proxy.server.com:8080 proxyuser : 代理服务器用户 proxypwd : 密码 proxy.server.com ： 代理服务器地址 8080 ： 代理服务器端口号 2.重设代理，恢复默认： 1git config --global --unset http.proxy 1git config --global --unset https.proxy 下面开始修改： 1.设置赛风本地代理端口： 2.修改 Git 配置： 1git config --global http.proxy http://127.0.0.1:12345 1git config --global https.proxy https://127.0.0.1:12345 3.将代码克隆到本地成功后，恢复 Git 默认配置： 1git config --global --unset http.proxy 1git config --global --unset https.proxy","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://laocaixw.github.io/tags/Git/"}]},{"title":"GitHub搭建个人博客(hexo)","slug":"Blog_Hexo_GitHub","date":"2016-06-08T04:13:00.000Z","updated":"2018-04-04T08:47:16.719Z","comments":true,"path":"2016/06/08/Blog_Hexo_GitHub/","link":"","permalink":"http://laocaixw.github.io/2016/06/08/Blog_Hexo_GitHub/","excerpt":"","text":"一.准备hexo 是一个工具，可以帮助我们自动生成博客网站的代码，我们只需要用 MarkDown 写好博客，再使用 hexo 生成网站代码，最后把网站代码部署到 GitHub 上即可。需要以下准备： 1.GitHub。 基于 Git 的代码托管网站，提供静态页面服务。首先要有一个GitHub账号，博客网站的代码是放在 GitHub 仓库上的。 2.Git。 需要安装 Git 版本控制器，类似 SVN 的工具。 3.Node.js。 需要安装 Node.js。 hexo 是基于 nodejs 的一套框架工具。 4.MarkDown。 程序员最爱的写文档工具，写博客需要用到。具体语法可以参考CSDN的MarkDown语法模板 下载。 二.安装 hexo 环境。安装好 Nodejs 后，就可以安装 hexo 框架了。 1.首先新建一个文件夹（涉及到代码的文件夹，请大家务必不要用中文），用于存放 hexo 框架，我这边以 D:\\work\\hexo 为例。 2.打开 CMD 命令窗口，cd 进入 hexo 文件夹，输入以下命令安装 hexo ： 1npm install hexo-cli -g 3.安装完成后，输入以下命令生成博客工程（文件夹），这边工程先命名为 blog ： 1hexo init blog 4.进入工程 blog 文件夹： 1cd blog 三.写文章安装完成后，可以看到 blog 目录下有一堆文件和文件夹， 其中： source 用于放 MarkDown 写的文章文档； themes 是存放博客主题的文件夹； public 文件夹中存放自动生成的网站代码。 知道这些就可以开始写博客了，可以看到 \\source\\_posts 下有一个默认的文档 helloworld ，就是一篇默认的博客。 1.新建一篇博客，在 D:\\work\\hexo\\blog 目录下，输入以下命令会在 D:\\work\\hexo\\blog\\source\\_posts 中生成一个 .md 后缀的 MarkDown 文件： 1hexo new \"文章标题\" 2.在生成的文件中写博客，一般的文本编辑器都可以编写 MarkDown 文档； 3.写完博客后，输入以下命令就可以在 public 目录下，自动生成静态的博客网站代码： 123hexo generate或hexo g 4.这时候启动本地服务，就可以预览网站（ http://localhost:4000/ ）效果了，启动服务命令： 1hexo server 四.部署到 GitHub 上 1.新建 GitHub 代码仓库，进入你的 GitHub 主页，点击右上角的加号，选择 New repository 新建项目。这里要注意，代码仓库格式必须是： XXX.github.io ，其中 XXX 必须是你 GitHub 的 ID。 2.克隆 GitHub 代码仓库到本地，找个合适的文件夹放置网站代码： 1git clone https://github.com/XXX/XXX.github.io.git https://github.com/XXX/XXX.github.io.git 是代码仓库地址，获取方式如下： 3.上传博客网站代码。前面写完文章，运行命令生成的网站代码都在 public 文件夹中，复制 public 目录下的所有文件，粘贴到上一步的代码仓库（XXX.github.io 文件夹）中。提交代码，即在代码仓库文件夹中，右键 Git Bash Here，依次执行以下命令： 123git add . // 添加修改git commit -m \"备注\" // 提交git push origin master // 上传到GitHub代码库 然后输入账号密码，等待上传完成后，过几分钟就可以看到网站效果。 注意：如果你是首次使用 Git ，它会提示你设置一些配置，只需按提示输入配置命令即可。 以下是附加的，有兴趣可以尝试。五.更换主题以上步骤完成后，你就有一个博客了，但是还是默认的主题 landscape。可以在这两个地方找自己喜欢的主题：hexo官网、有哪些好看的 Hexo 主题？，也可以直接上网搜 hexo 主题。 以此博客的主题 Maupassant 为例： 1.克隆主题到 themes 文件夹中： 1git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 2.按照文档要求，安装插件： 12npm install hexo-renderer-pug --savenpm install hexo-renderer-sass --save 3.修改博客 hexo 目录下的 _config.yml 文件：将 theme 项的 landscape 改为 maupassant。这里提示下，_config.yml 中还有博客的其他配置，可以按需更改。 4.配置主题。主题文件夹中也有一个 _config.yml 文件，这个是主题里相关的配置，一般主题都会有配置文档可以参考。 六.RSS订阅RSS就是提供接口出来，让别人可以订阅你的博客。hexo 有对应相关的插件。输入以下命令安装插件： 1npm install hexo-generator-feed --save 在博客的配置文件 _config.yml 里添加如下配置，： 12345678feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &apos; &apos; 编译之后，public 根目录下会生成 atom.xml 文件，这就说明成功了。另外，一般主题都会默认配置好 RSS 文件的路径，如果没有，则在主题的配置文件里填上即可。 七.404网页你还可以给自己自定义一个 404 网页，一旦访问你的网站的某个页面不存在时，就会跳到 404 网页。网上也有很多模板可以用，如：腾讯的寻子公益404页面。 在 source 下新建一个 404.html 或 404.md 文件，把以下代码复制进去： &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt; 两个参数”homePageUrl”、”homePageName”可以按需修改。","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://laocaixw.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"http://laocaixw.github.io/tags/Hexo/"}]},{"title":"KMP算法的个人理解","slug":"Algorithm_KMP","date":"2016-05-06T13:14:00.000Z","updated":"2017-11-16T06:44:22.797Z","comments":true,"path":"2016/05/06/Algorithm_KMP/","link":"","permalink":"http://laocaixw.github.io/2016/05/06/Algorithm_KMP/","excerpt":"","text":"自学了一段时间，刚刚准备转行做软件开发，面试过程中被指出计算机基础知识薄弱。因为是非科班出生，确实有些计算机方面的基础没有学过，也开始恶补这些方面的东西。最近在学习数据结构与算法过程中，学到 KMP 算法，甚是难解。看了阮一峰的网络日志后才慢慢理解，但也发现其中的瑕疵，在此也顺带指出，至于对或不对，还请各位看客指正。 图片和例子讲解均引自阮一峰的网络日志，稍作修改，侵改。 正文举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”，即字符串”ABCDABD”是否是字符串”BBC ABCDAB ABCDABCDABDE”的子串。 定义 字符串1：”BBC ABCDAB ABCDABCDABDE”(包含空格) 搜索词2：”ABCDABD” 普通的字符串匹配算法将搜索词2中的第一位“A”，与字符串1中的第一位“B”匹配，若不匹配，则与字符串1中的第二位“B”匹配 … 直到匹配到第五位“A”，可匹配。 将搜索词2中的第二位“B”，与字符串1中的第六位“B”匹配，可匹配，则继续进行后面的字符匹配。 直到搜索词2与字符串1的某段完全匹配，则可认为搜索词2是字符串1的子串。 这种方法简单粗暴，但效率极低。 KMP 算法1.首先，字符串1的第一个字符与搜索词2的第一个字符，进行比较。因为 B 与 A 不匹配，所以搜索词后移一位。 2.因为B与A不匹配，搜索词再往后移。 3.就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。 4.接着比较字符串和搜索词的下一个字符，还是相同。 5.直到字符串有一个字符，与搜索词对应的字符不相同为止。 6.这时，普通的字符串匹配算法是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。 7.一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 8.怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。 9.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已经匹配对的字符数 - 最后一个匹配对的部分匹配值 + 当前匹配错的部分匹配值 因为 6 - 2 + 0 等于4，所以将搜索词向后移动4位。 10.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0 + 0，结果为 2，于是将搜索词向后移2位。 11.因为空格与A不匹配，继续后移一位。 12.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2 + 0，继续将搜索词向后移动4位。 13.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。 部分匹配表下面介绍 部分匹配表 是如何产生的 “部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， “A”的前缀和后缀都为空集，共有元素的长度为0； “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0； “ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； “ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； “ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； “ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； “ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 “部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 如果大家有兴趣可以用以下两组数进行匹配，就会发现一个不一样的过程： 字符串：ABCABDABCABC 搜索词：ABCABC","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://laocaixw.github.io/tags/算法/"}]}]}